[{"content":"Введення Zsh, або Z Shell, — це потужна та багатофункціональна оболонка командного рядка для Unix-подібних операційних систем, включаючи Linux і BSD (Berkeley Software Distribution). Це розширена версія Bourne Shell (sh) з численними вдосконаленнями та додатковими функціями. Zsh має на меті забезпечити більш інтерактивний і зручний досвід для користувачів оболонки.\nОсь кілька причин, чому Zsh часто вважають однією з найкращих оболонок для систем Unix/Linux/BSD:\nРедагування командного рядка: Zsh пропонує розширені можливості редагування командного рядка, що дозволяє користувачам легко переходити та редагувати команди. Він підтримує такі функції, як розширення історії, виправлення орфографії та вдосконалене зіставлення шаблонів.\nНалаштування: Zsh можна налаштувати. Користувачі можуть налаштовувати різні аспекти поведінки оболонки, такі як швидкий вигляд, прив’язки клавіш і параметри завершення. Великі параметри конфігурації дозволяють адаптувати його до індивідуальних уподобань і робочих процесів.\nАвтодоповлення команд: Zsh забезпечує Автодоповлення команд з урахуванням контексту, полегшуючи навігацію файловою системою та завершуючи імена та аргументи команд. Він може завершувати не лише команди, але й шляхи до файлів, змінні тощо.\nПлагіни та розширення: Zsh підтримує плагіни та розширення, які покращують його функціональність. Такі інструменти, як Oh-My-Zsh і Prezto, є популярними фреймворками, які спрощують керування конфігураціями Zsh і додають додаткові функції за допомогою плагінів.\nВиправлення орфографії: Zsh має вбудовану функцію виправлення орфографії, яка допомагає користувачам уникати помилок. Якщо ви неправильно введете команду або шлях до файлу, Zsh може запропонувати виправлення.\nІнтерактивні функції: Zsh містить інтерактивні функції, які покращують загальну взаємодію з користувачем, наприклад можливість легко переглядати історію команд, здійснювати пошук серед попередніх команд і повторно використовувати або ефективно змінювати команди.\nСумісність із оболонкою Bourne: Zsh сумісний із синтаксисом оболонки Bourne (sh), що робить його відповідною заміною для sh або Bash. Існуючі сценарії оболонки, швидше за все, працюватимуть у Zsh без змін.\nХоча Zsh пропонує багатий набір функцій, вибір «найкращої» оболонки часто залежить від індивідуальних уподобань і конкретних випадків використання. Інші популярні оболонки включають Bash (Bourne Again SHell) і Fish (Friendly Interactive SHell), кожна з яких має свої сильні сторони та характеристики. Зрештою, найкраща оболонка — це та, яка узгоджується з вашим робочим процесом і відповідає вашим конкретним вимогам.\nВстановлення Встановіть пакет ZSH Щоб установити пакет ZSH у вашій системі Linux, розгляньте можливість використання менеджера пакунків, який постачається з вашим дистрибутивом. Це робиться по-різному залежно від вашого дистрибутива, наприклад:\nДля Arch Linux:\nsudo pacman -S zsh Для Fedora, Red Hat:\nsudo dnf install zsh Для Debian, Ubuntu, Linux Mint, ElementaryOS:\nsudo apt install zsh У моєму випадку я встановлюю його для Arch Linux:\nВстановлення ZSH оболонкою за замовчуванням Щоб зробити новий встановлений ZSH стандартним для вашого користувача, введіть команду нижче та введіть свій пароль користувача для підтвердження:\nchsh -s $(which zsh) Після цього рекомендується перезавантажити систему, при наступному перезавантаженні оболонка ZSH буде використана для вашого користувача. Щоб перезавантажити комп’ютер, ви можете скористатися командою sudo reboot або просто скористатися графічним інтерфейсом робочого середовища для виконання перезавантаження.\nПерше налаштування Щойно ви відкриєте програму терміналу після перезавантаження, zsh запропонує вам створити файли конфігурації за замовчуванням. Для застосування конфігурації натисніть на клавіатурі «0».\nВстановлення Oh My ZSH Oh My Zsh — це платформа з відкритим вихідним кодом і менеджер конфігурації для Zsh, Z Shell. Він був створений, щоб полегшити користувачам керування конфігураціями Zsh і покращити роботу командного рядка. Oh-My-Zsh надає колекцію плагінів, тем і допоміжних функцій, які можна легко інтегрувати в Zsh, дозволяючи користувачам налаштовувати та розширювати функціональність свого середовища оболонки.\nНайпростіший спосіб щоб інсталювати ZSH — скористатися сценарієм інсталяції зі Oh My Zsh GitHub Repository. Можна виконати інсталяційний сценарій, завантаживши його, ось так:\nsh -c \u0026#34;$(wget https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh -O -)\u0026#34; Після завершення скрипта ви побачите встановлену оболонку Oh My Zsh, як на знімку екрана нижче.\nНалаштування теми Oh My ZSH Oh My Zsh має багато попередньо встановлених тем, які знаходяться в папці ~/.oh-my-zsh/themes/.\nВи можете змінити свій файл .zshrc і використовувати попередньо встановлену тему.\nnano .zshrc А щоб змінити тему на agnoster, наприклад, знайдіть параметр ZSH_THEME і змініть його так:\nZSH_THEME=\u0026#34;agnoster\u0026#34; Встановлення сторонної теми Oh My ZSH Особисто мені тема Powerlevel10k найбільше подобається серед інших, тому в цьому прикладі я покажу, як її встановити.\nВстановлення сумісного шрифта терміналу Щоб тема могла правильно відображати деякі символи, ваш термінал має використовувати спеціальний сумісний фон Meslo LGS NF. Для цього ви можете виконати інструкції зі сховища GitHub.\nНайпростіший спосіб - завантажити 4 файли шрифтів:\nMesloLGS NF Regular.ttf MesloLGS NF Bold.ttf MesloLGS NF Italic.ttf MesloLGS NF Bold Italic.ttf Щоб зробити їх доступними для всієї системи, перемістіть ці 4 файли до папки /usr/share/fonts:\n1 2 3 4 sudo mv \u0026#34;MesloLGS NF Regular.ttf\u0026#34; /usr/share/fonts sudo mv \u0026#34;MesloLGS NF Bold.ttf\u0026#34; /usr/share/fonts sudo mv \u0026#34;MesloLGS NF Italic.ttf\u0026#34; /usr/share/fonts sudo mv \u0026#34;MesloLGS NF Bold Italic.ttf\u0026#34; /usr/share/fonts Щоб очистити кеш шрифтів, виконайте команду:\nsudo fc-cache Останнім кроком є зміна шрифту вашого терміналу. Це може залежати від терміналу, який ви використовуєте, але зазвичай ви можете просто змінити його в графічних налаштуваннях терміналу. У моєму випадку я налаштував його на використання Meslo LGS NF Regular 12.\nВстановлення теми Powerlevel10k Спочатку завантажте тему Powerlevel10k у свій каталог користувальницьких тем, це можна легко зробити за допомогою однієї команди:\ngit clone --depth=1 https://github.com/romkatv/powerlevel10k.git ${ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom}/themes/powerlevel10k Потім змініть файл .zshrc:\nnano .zshrc і встановіть параметр ZSH_THEME рівним powerlevel10k/powerlevel10k:\nZSH_THEME=\u0026#34;powerlevel10k/powerlevel10k\u0026#34; Після збереження файлу скористайтеся наведеною нижче командою, щоб застосувати зміни:\nsource ~/.zshrc Перше налаштування Powerlevel10k Під час першого запуску нового спеціального рівня Powerlevel10k запуститься майстер налаштування теми Powerlevel10k. Ви завжди можете знову запустити цей майстер, використовуючи команду терміналу p10k configure. Майстер має кілька кроків, просто натисніть відповідні клавіші на клавіатурі, щоб відповісти. Нижче я покажу, як конфігурація виглядає в моєму випадку.\n1. Переконайтеся, що кілька символів шрифту відображаються правильно. Я просто відповів «так» на ці запитання (натиснувши «y» на клавіатурі), тому що все, що стосується відтворення символів, відображалося правильно.\n2. Налаштуйте стиль теми Усі параметри в цьому розділі дозволяють змінити дизайн теми відповідно до ваших особистих уподобань. Я покажу, які відповіді я ввів у майстер, якщо ви захочете відтворити точну поведінку теми з цього посібника.\nШвидке налаштування стилю дозволить налаштувати основний вигляд і відчуття, тут я відповів «3». Набір символів є важливим параметром, і насправді Юнікод дозволяє відображати більше символів, тому я настійно рекомендую відповісти тут «1». Цей параметр дозволяє показувати або приховувати поточний час у терміналі. Я не бачу в цьому жодної практичної користі, тому відповів n тут. Наступні налаштування стосуються зовнішнього вигляду теми, ви можете вибрати те, що вам подобається особисто.\nФункція instant prompt дозволяє скоротити час завантаження оболонки ZSH, тому я настійно рекомендую ввімкнути її, відповівши тут «1». Останнім кроком є застосування змін до .zshrc, просто дайте тут відповідь y. Якщо все налаштовано правильно, ви побачите нову тему оболонки.\nУвімкніть вбудовані плагіни Oh My ZSH Zsh підтримує плагіни та розширення, які покращують його функціональність. Oh-My-Zsh дозволяє легко керувати конфігураціями Zsh і додавати додаткові функції за допомогою плагінів.\nЩоб переглянути список плагінів, які входять до складу Oh My ZSH, ви можете ввести команду:\nls -a ~/.oh-my-zsh/plugins/ У моєму випадку у мене є такі плагіни:\nПотім ви можете змінити свій файл .zshrc:\nnano .zshrc і встановити параметр plugins для завантаження потрібних вам плагінів, у моєму випадку (як розробника Android) мені потрібні плагіни git і adb:\nplugins=(git adb) Потім застосуйте зміни до оболонки:\nsource ~/.zshrc Встановлення сторонніх плагінів Також Oh My ZSH дозволяє встановлювати та використовувати сторонні плагіни. Наприклад, давайте встановимо плагіни zsh-autosuggestions, щоб мати хороші рекомендації щодо команд введення на основі історії.\nВстановлення дуже схоже на встановлення спеціальної теми. Спочатку клонуйте плагін у каталог настроюваних плагінів.\ngit clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions Тоді ви можете змінити свій файл .zshrc так само, як я показав у розділі статті вище, тому в результаті ви матимете:\nplugins=(git adb zsh-autosuggestions) Потім застосуйте зміни до оболонки:\nsource ~/.zshrc Після цього спробуйте щось набрати, і ви побачите пропозицію. Наприклад, я ввів \u0026ldquo;neo\u0026rdquo;, а плагін пропонує використовувати \u0026ldquo;neofetch\u0026rdquo;:\nУвімкнення автоматичних оновлень Oh-My-Zsh має вбудований механізм оновлення, який допомагає користувачам підтримувати інсталяцію в актуальному стані за допомогою останніх змін, удосконалень і виправлень помилок, внесених спільнотою. Він також надає можливість автоматичного оновлення, але за умовчанням його вимкнено.\nЩоб налаштувати автоматичне оновлення, вам слід встановити цю директиву у файлі .zshrc:\nzstyle \u0026#39;:omz:update\u0026#39; mode auto Висновки Таким чином, ZSH є більш багатофункціональною оболонкою, яка може зробити вашу роботу ефективнішою, розширюючи функціональність оболонки за допомогою спеціальних плагінів, тому її можна вважати кращою альтернативою bash, яка є оболонкою за замовчуванням у будь-якому сучасному дистрибутиві Linux.\n","date":"2023-11-26T00:00:00Z","image":"https://blog.moroz.cc/uk/post/%D1%8F%D0%BA-%D0%B2%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%B8%D1%82%D0%B8-%D1%82%D0%B0-%D0%BD%D0%B0%D0%BB%D0%B0%D1%88%D1%82%D1%83%D0%B2%D0%B0%D1%82%D0%B8-zsh-%D1%83-linux/header_hu6914af8cdb8921216861b6ef227624ec_122422_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.moroz.cc/uk/post/%D1%8F%D0%BA-%D0%B2%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%B8%D1%82%D0%B8-%D1%82%D0%B0-%D0%BD%D0%B0%D0%BB%D0%B0%D1%88%D1%82%D1%83%D0%B2%D0%B0%D1%82%D0%B8-zsh-%D1%83-linux/","title":"Як встановити та налаштувати ZSH у Linux"},{"content":"Введення Використовуючи systemd-boot як завантажувач, більш зручно, щоб система запам’ятовувала останню вибрану опцію під час кожного наступного завантаження. Це особливо корисно для користувачів, які використовують різниі операційні системи або ядра Linux. Налаштувавши systemd-boot на запам\u0026rsquo;ятовування останньої вибраної опції завантаження, ви можете спростити процес завантаження та уникнути необхідності вручну вибирати потрібний параметр кожного разу, коли система перезавантажується.\nЗміна конфігураційного файлу Щоб налаштувати запам\u0026rsquo;ятовування systemd-boot, потрібно змінити файл конфігурації `loader.conf``. Точне розташування цього файлу може відрізнятися залежно від дистрибутива Linux, який ви використовуєте.\nОсобисто я використовував кілька дистрибутивів Linux, і шлях до loader.conf був різним у кожному з них, наприклад:\nДля Ubuntu це було /boot/efi/loader/loader.conf Для Arch Linux це було /boot/loader/loader.conf Для EndeavourOS це був /efi/loader/loader.conf Щоб змінити файл, відкрийте термінал і виконайте такі дії:\nВідкрийте файл loader.conf для редагування, наприклад: sudo nano /boot/loader/loader.conf Змініть параметр default, як показано нижче: default @saved Збережіть файл (В nano це робиться клавіатурним скороченням Crtl + O). Після того як ви виберете деяку опцію (ОС чи ядро) при завантаженні комп\u0026rsquo;ютера в systemd-boot, то її буде збережено та запропоновано автоматично як стандартниу під час наступного завантаження.\nВисновки Налаштувавши systemd-boot на запам\u0026rsquo;ятовування останньої вибраної опції, ви можете оптимізувати процес завантаження та покращити загальну взаємодію з користувачем. Незалежно від того, чи використовуєте ви Arch Linux, Ubuntu або інший дистрибутив, який використовує systemd-boot, ця проста модифікація може заощадити ваш час і зробити запуск вашої системи ефективнішим.\nНе забудьте адаптувати шляхи до файлів і команди відповідно до специфіки вашого дистрибутива. З цією конфігурацією ваша система автоматично завантажуватиметься з останнього вибраного запису, зменшуючи потребу в ручному втручанні під час процесу завантаження.\n","date":"2023-11-22T00:00:00Z","image":"https://blog.moroz.cc/uk/post/%D0%BD%D0%B0%D0%BB%D0%B0%D1%88%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F-systemd-boot-%D0%B4%D0%BB%D1%8F-%D0%B7%D0%B0%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D0%BE%D0%B2%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F-%D0%BE%D1%81%D1%82%D0%B0%D0%BD%D0%BD%D1%8C%D0%BE%D1%97-%D0%B2%D0%B8%D0%B1%D1%80%D0%B0%D0%BD%D0%BE%D1%97-%D0%BE%D0%BF%D1%86%D1%96%D1%97/header_hu0e765b8aca8d9ba54a80770b06516939_1619_120x120_fill_box_smart1_3.png","permalink":"https://blog.moroz.cc/uk/post/%D0%BD%D0%B0%D0%BB%D0%B0%D1%88%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F-systemd-boot-%D0%B4%D0%BB%D1%8F-%D0%B7%D0%B0%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D0%BE%D0%B2%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F-%D0%BE%D1%81%D1%82%D0%B0%D0%BD%D0%BD%D1%8C%D0%BE%D1%97-%D0%B2%D0%B8%D0%B1%D1%80%D0%B0%D0%BD%D0%BE%D1%97-%D0%BE%D0%BF%D1%86%D1%96%D1%97/","title":"Налаштування systemd-boot для запам'ятовування останньої вибраної опції"},{"content":"Введення Наразі існує дуже багато платформ для онлайн-стримінгу відеоконтенту, такі як YouTube, Twitch, та інші. Для трансляції потокового відео через мережу інтернет вони використовують прокотол RTMP (Real-Time Messaging Protocol). Хоча ці платформи мають потужні можливості для проведення відеотрансляцій, в деяких випадках незалежність від стримінгової платформи та її правил є цілком доцільною.\nУ цій статті наведемо інструкцію з деплойменту RTMP сервіса на базі Nginx-RTMP, що дозволить приймати RTMP потік від комп\u0026rsquo;ютера стримера, та конвертувати його в сучасні формати HLS та DASH для перегляду у програмі-приймачі.\nПередумови Для реалізації RTMP сервісу, вам потрібно мати:\nНову віртуальну машину або фізичний сервер на базі ОС Linux. Комп\u0026rsquo;ютер для ведення трансляції. Для роботи поза локальною мережею, в глобальній мережі інтернет:\nВиділену IP адресу. Домен. В інструкції буде використано VPS на базі Debian 11.\nРобота з Nginx-RTMP Встановлення Перш за все, необхідно встановити пакети nginx та libnginx-mod-rtmp. Для цього потрібно виконати команди:\n1 2 sudo apt update sudo apt install nginx libnginx-mod-rtmp Налаштування RTMP Після встановлення, потрібно сконфігурувати веб-сервер Nginx таким чином, щоб він прослуховував порт 1935 для отримання RTMP-потоку. Для цього потрібно відредагувати файл /etc/nginx/nginx.conf:\nsudo nano /etc/nginx/nginx.conf В кінці файла, потрібно дописати конфігурацію RTMP сервера:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 ... rtmp { server { listen 1935; chunk_size 4096; allow publish 127.0.0.1; allow publish 192.168.0.0/24; deny publish all; application live { live on; record off; hls on; hls_path /var/www/html/stream/hls; hls_fragment 3; hls_playlist_length 60; dash on; dash_path /var/www/html/stream/dash; } } } ... Тлумачення важливих аспектів цієї конфігурації:\nlisten 1935 - задає порт, на якому працює RTMP сервер. chunk_size 4096 - задає розмір блоку, по 4 Кб. allow publish [IP / Subnet] - кожна строка вказує IP або підмережу, яким дозволено відсилати RTMP потік на сервер. deny publish all - забороняє приймати RTMP потік від всіх інших адрес/мереж. application live - конфігурація для перетворення RTMP в формати HLS та DASH, де hls_path та dash_path вказують шляхи до каталогів для розміщення плейлистів. live on - дозволяє приймати дані відеопотоком. record off - вимикає запис відеопотоку у файл на диску. Налаштвання HLS, DASH Далі, необхідно розгорнути віртуальний хост, що дозволить отримувати доступ до HLS або DASH потоків через HTTP/HTTPS протокол.\nСпочатку треба створити дві директорії для зберігання фрагментів відеопотоку для HLS та DASH:\n1 2 sudo mkdir -p /var/www/html/stream/hls sudo mkdir -p /var/www/html/stream/dash Та також встановити власника та права:\n1 2 sudo chown -R www-data:www-data /var/www/html/stream sudo chmod -R 755 /var/www/html/stream Для роботи віртуального хоста, потрібно створити новий конфігураційний файл (наприклад rtmp) в каталозі /etc/nginx/sites-available:\nsudo nano /etc/nginx/sites-available/rtmp Хост файл rtmp складається з наступного:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 server { listen 443 ssl; listen 80; server_name rtmp.yourdomain.com; ssl_certificate /etc/ssl/yourdomain.crt; ssl_certificate_key /etc/ssl/yourdomain.key; ssl_protocols SSLv3 TLSv1 TLSv1.1 TLSv1.2; location / { add_header Access-Control-Allow-Origin *; root /var/www/html/stream; } } types { application/dash+xml mpd; } Пояснення до цієї конфігурації:\nЗамініть rtmp.yourdomain.com на свій домен. Якщо ви хочете використовувати SSL, то також запишіть файли сертифікату та ключа за шляхами /etc/ssl/yourdomain.crt та /etc/ssl/yourdomain.key. Якщо ви не хочете використовувати SSL, то приберіть з файлу рядки що починаються з ssl та listen 443 ssl. Для того щоб всі зроблені конфігурації вступили в дію, треба увімкнути віртуальний хост та перезавантажити Nginx:\n1 2 sudo ln -s /etc/nginx/sites-available/rtmp /etc/nginx/sites-enabled/ sudo service nginx restart Ведення трансляції в OBS Studio Для ведення трансляції найкраще за все підходить програма OBS Studio.\nПершочергово необхідно створити сцену, налаштувати звук, та зовнішній вигляд трансляції.\nДля налаштування параметрів стримінгу, потрібно зайти в Налаштування та вибрати вкладку Stream. Там необхідно задати наступні параметри:\nService: Custom Server: rtmp://rtmp.yourdomain.com/live (замість домену можна вказати IP, наприклад http://11.22.33.44/live) Stream Key: obs_stream Приклад налаштувань:\nДля запуску відеотрансляції, необхідно натиснути Start Streaming в головномі вікні програми:\nПерегляд трансляції Тепер трансляцію можна переглянути за допомогою будь-якої програми, що підтримує протоколи HLS та DASH. Найпростішим шляхом буде перегляд у програмі VLC, відкривши посилання на потік.\nДля початку, розберемося як формується посилання на потоки в сконфігурованому сервісі:\nHLS: {protocol}://{domain}/hls/{stream key}.m3u8 DASH: {protocol}://{domain}/dash/{stream key}.mpd Наприлкад, якщо ви розгорнули сервіс за адресою rtmp.yourdomain.com що використовує SSL, та в налаштуваннях OBS вказали ключ obs_stream, то в такому випадку посилання будуть такими:\n1 2 https://rtmp.yourdomain.com/hls/obs_stream.m3u8 https://rtmp.yourdomain.com/dash/obs_stream.mpd Для перегляду в VLC, потрібно натиснути Ctrl + N, або перейти в меню Media \u0026gt; Open Network Stream, вказати посилання на один із форматів, та натиснути Play.\nВисновки Таким чином можна створити свій сервіс для проведення трансляцій, що буде незалежним від популярних сервісів.\nПереваги такого рішення:\nПриватність та повний контроль над інфраструктурою, гарантія що дані потоку не зберігаються. Не потрібно дотримуватися правил сервісу (наприклад заборону транслювати певний контент). Але є і певні недоліки:\nТаке рішення вимагає певних ресурсів сервера. Власнику потрібно витрачати час та кошти на обслуговування та підтримку безпеки своєї інфраструктури. ","date":"2022-07-20T00:00:00Z","image":"https://blog.moroz.cc/uk/post/%D1%80%D0%BE%D0%B7%D0%B3%D0%BE%D1%80%D1%82%D0%B0%D0%BD%D0%BD%D1%8F-rtmp-%D1%81%D0%B5%D1%80%D0%B2%D0%B5%D1%80%D0%B0-%D0%B4%D0%BB%D1%8F-%D1%81%D1%82%D1%80%D0%B8%D0%BC%D1%96%D0%BD%D0%B3%D1%83-%D0%B2%D0%B8%D0%BA%D0%BE%D1%80%D0%B8%D1%81%D1%82%D0%BE%D0%B2%D1%83%D1%8E%D1%87%D0%B8-nginx-rtmp/header_hu41968337912a42023606e3de60723367_1230034_120x120_fill_q75_box_smart1.jpeg","permalink":"https://blog.moroz.cc/uk/post/%D1%80%D0%BE%D0%B7%D0%B3%D0%BE%D1%80%D1%82%D0%B0%D0%BD%D0%BD%D1%8F-rtmp-%D1%81%D0%B5%D1%80%D0%B2%D0%B5%D1%80%D0%B0-%D0%B4%D0%BB%D1%8F-%D1%81%D1%82%D1%80%D0%B8%D0%BC%D1%96%D0%BD%D0%B3%D1%83-%D0%B2%D0%B8%D0%BA%D0%BE%D1%80%D0%B8%D1%81%D1%82%D0%BE%D0%B2%D1%83%D1%8E%D1%87%D0%B8-nginx-rtmp/","title":"Розгортання RTMP сервера для стримінгу, використовуючи Nginx RTMP"},{"content":"Введення Mega.nz одне з найдоступніших хмарних сховищ за об\u0026rsquo;ємом, адже надає своїм новим користувачам 50Gb хмарного дискового простору абсолютно безкоштовно. Є також платні тарифи, які дозволяють розширити хмару аж до 4 терабайт. Але для резервних копій сайтів та баз даних MySQL цілком вистачає навіть 50Gb. Також, є набір консольних утиліт megatools для скачування та вивантаження файлів на віддалену хмару.\nНалаштування Встановлення megatools Для початку зареєструйте та активуйте собі обліковий запис на сайті mega.nz, якщо у вас його досі немає.\nДалі треба підключитися до сервера по SSH, та встановити необхідні для збирання megatools пакети:\nsudo apt-get -y install build-essential libglib2.0-dev libssl-dev libcurl4-openssl-dev libgirepository1.0-dev Після цього на офіційному сайті варто знайти посилання на завантаження megatools, яке потім використовуємо для завантаження командою wget.\n1 2 3 cd /opt wget https://megatools.megous.com/builds/megatools-1.9.97.tar.gz tar -xvzf megatools-1.9.97.tar.gz Після того як ми завантажили та розархівували вихідний код, треба його скомпілювати. Це можна зробити за допомогою наступної послідовності команд:\n1 2 3 4 cd megatools-1.9.97 ./configure make make install Якщо все скомпілювалося і встановилося без помилок, можна переходити до наступного етапу, а саме написання скрипта для створення і вивантаження бекапів в хмару.\nСтворення скрипта для резервного копіювання Спочатку створюємо файл із даними для входу до облікового запису:\n1 2 cd ~ nano .megarc Файл має бути наповнено таким чином:\n1 2 3 [Login] Username = {Ваш логін} Password = {Ваш пароль} Так як у нас дані для входу зберігаються у відкритому вигляді, зробимо їх доступними лише для root.\nchmod 640 .megarc Тепер перевіримо правильність введення логіну з паролем, для цього вводимо команду:\nmegals Якщо всі налаштування корректні, вона має вивести на екран список файлів. Якщо команда не вивела список файлів, то перевіряємо правильність введення пароля, якщо вивела, то переходимо до наступного кроку створення скрипту для бекапу. В даному випадку скрипти зберігаються в директорії /opt/scripts з модифікованими правами.\nnano /opt/scripts/do_backup.sh Скрипт виглядає так:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 #!/bin/bash SERVER=\u0026#34;server\u0026#34; DAYS_TO_BACKUP=7 WORKING_DIR=\u0026#34;/root/tmp_dir\u0026#34; BACKUP_MYSQL=\u0026#34;true\u0026#34; MYSQL_USER=\u0026#34;{Ваш користувач MySQL}\u0026#34; MYSQL_PASSWORD=\u0026#34;{Ваш пароль користувача MySQL}\u0026#34; DOMAINS_FOLDER=\u0026#34;/var/www\u0026#34; ################################## # Створюємо тимчасову папку для створення архівів rm -rf ${WORKING_DIR} mkdir ${WORKING_DIR} cd ${WORKING_DIR} # Архівуємо папку /etc cd / tar cJf ${WORKING_DIR}/etc.tar.gx etc cd - \u0026gt; /dev/null # Бекап бази даних MySQL if [ \u0026#34;${BACKUP_MYSQL}\u0026#34; = \u0026#34;true\u0026#34; ] then mkdir ${WORKING_DIR}/mysql for db in $(mysql -u${MYSQL_USER} -p${MYSQL_PASSWORD} -e \u0026#39;show databases;\u0026#39; | grep -Ev \u0026#34;^(Database|mysql|information_schema|performance_schema|phpmyadmin)$\u0026#34;) do #echo \u0026#34;processing ${db}\u0026#34; mysqldump --opt -u${MYSQL_USER} -p${MYSQL_PASSWORD} \u0026#34;${db}\u0026#34; | gzip \u0026gt; ${WORKING_DIR}/mysql/${db}_$(date +%F_%T).sql.gz done #echo \u0026#34;all db now\u0026#34; mysqldump --opt -u${MYSQL_USER} -p${MYSQL_PASSWORD} --events --ignore-table=mysql.event --all-databases | gzip \u0026gt; ${WORKING_DIR}/mysql/ALL_DATABASES_$(date +%F_%T).sql.gz fi # Бекап сайтів mkdir ${WORKING_DIR}/domains for folder in $(find ${DOMAINS_FOLDER} -mindepth 1 -maxdepth 1 -type d) do cd $(dirname ${folder}) tar cJf ${WORKING_DIR}/domains/$(basename ${folder}).tar.xz $(basename ${folder}) cd - \u0026gt; /dev/null done ################################## # Захищаємось від помилок dbus-error export $(dbus-launch) # Створюємо на хмарі папку з ім\u0026#39;ям сервера, а в ній ще одну з сьогоднішньою датою [ -z \u0026#34;$(megals --reload /Root/backup_${SERVER})\u0026#34; ] \u0026amp;\u0026amp; megamkdir /Root/backup_${SERVER} # Очистка старих непотрібних логів while [ $(megals --reload /Root/backup_${SERVER} | grep -E \u0026#34;/Root/backup_${SERVER}/[0-9]{4}-[0-9]{2}-[0-9]{2}$\u0026#34; | wc -l) -gt ${DAYS_TO_BACKUP} ] do TO_REMOVE=$(megals --reload /Root/backup_${SERVER} | grep -E \u0026#34;/Root/backup_${SERVER}/[0-9]{4}-[0-9]{2}-[0-9]{2}$\u0026#34; | sort | head -n 1) megarm ${TO_REMOVE} done # Створюємо папку curday=$(date +%F) megamkdir /Root/backup_${SERVER}/${curday} 2\u0026gt; /dev/null # Завантажуємо файли на віддалену хмару megacopy --reload --no-progress --local ${WORKING_DIR} --remote /Root/backup_${SERVER}/${curday} \u0026gt; /dev/null # Вбиваємо DBUS-daemon kill ${DBUS_SESSION_BUS_PID} rm -f ${DBUS_SESSION_BUS_ADDRESS} # Видаляємо тимчасові файли rm -rf ${WORKING_DIR} exit 0 Тепер потрібно дозволити виконання скрипта:\nchmod a+x /opt/scripts/do_backup.sh Далі необхідно протестувати скрипт, безпосередньо виконавши його:\n/opt/scripts/do_backup.sh Після цього можна зайти на аккаунт mega через веб-інтерфейс, та перевірити що там з\u0026rsquo;явилися потрібні файли.\nСтворення правила автозапуску скрипта в crontab Тепер щоб скрипт запускався за певним тимчасовим розкладом, додамо його до crontab.\n04 04 * * * root /opt/scripts/do_backup.sh Оптимальність використання В моєму випадку папка з бекапом має розмір 538,8 Mb.\nВсього на хмарі 50000 Mb вільного місця. Нехай у нас кожен бекап приблизно важить 550 Mb. Ділимо 50000 на 550, маємо:\n50000 / 550 ≈ 90.9 Це означає, що хмари вистачить на 90 бекапів, що досить велика цифра, особливо якщо врахувати безкоштовність сервісу Mega.\nАле оптимальність вцілому залежить від чинників:\nРозмір бекапу Частота резервного копіювання Тривалість зберігання кожного бекапу Тому для кожного окремого випадку доцільно оцінювати оптимальність окремо.\n","date":"2016-10-02T00:00:00Z","image":"https://blog.moroz.cc/uk/post/%D0%B0%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82%D0%B8%D1%87%D0%BD%D0%B8%D0%B5-%D1%80%D0%B5%D0%B7%D0%B5%D1%80%D0%B2%D0%BD%D0%B5-%D0%BA%D0%BE%D0%BF%D1%96%D1%8E%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F-%D1%81%D0%B5%D1%80%D0%B2%D0%B5%D1%80%D0%B0-%D0%B2-%D1%85%D0%BC%D0%B0%D1%80%D0%BD%D0%B5-%D1%81%D0%B5%D1%80%D0%B5%D0%B4%D0%BE%D0%B2%D0%B8%D1%89%D0%B5-mega.nz/header_hu07d9fa8bf00f81164ad47a9c5dedba00_591360_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.moroz.cc/uk/post/%D0%B0%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82%D0%B8%D1%87%D0%BD%D0%B8%D0%B5-%D1%80%D0%B5%D0%B7%D0%B5%D1%80%D0%B2%D0%BD%D0%B5-%D0%BA%D0%BE%D0%BF%D1%96%D1%8E%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F-%D1%81%D0%B5%D1%80%D0%B2%D0%B5%D1%80%D0%B0-%D0%B2-%D1%85%D0%BC%D0%B0%D1%80%D0%BD%D0%B5-%D1%81%D0%B5%D1%80%D0%B5%D0%B4%D0%BE%D0%B2%D0%B8%D1%89%D0%B5-mega.nz/","title":"Автоматичние резервне копіювання сервера в хмарне середовище Mega.nz"},{"content":"Введення SSH Тунелі дозволяють перенаправляти певні порти на віддаленому сервері або локально. Це дуже зручно, коли нам потрібно потрапити на конкретний сервер у локальній мережі.\nТехнічно є можливість перенаправляти можна як локальні, так і віддалені порти. Ми розглянемо обидва випадки.\nПеренаправлення локального порта Розглянемо ситуацію, коли ми перебуваємо всередині локальної мережі, де доступ в інтернет блокується фаєрволлом усім, крім одного сервера, що має прямий доступ до інтернету. У нас є доступ до цього сервера SSH. Наше завдання полягає в тому, щоб підключитися до віддаленого сервера, який знаходиться у зовнішній мережі SSH.\nРозглянемо приклад:\nssh -f -N -L 2222:212.212.212.212:22 user@111.111.111.111 Ця команда створить тунель, прокинувши порт 22 віддаленого сервера через локальний сервер, і ми зможемо підключитися до віддаленого сервера через порт 2222, який слухатиметься на локальному інтерфейсі нашого ПК.\nЗалишаємо термінал із тунельною сесією запущеним, у новому терміналі підключаємося до віддаленого сервера командою:\nssh -p2222 127.0.0.1 Таким чином, ми отримали доступ до SSH віддаленого сервера.\nПеренаправлення віддаленого порту Цей випадок протилежний до перенаправлення локального порта. Розглянемо ту ж саму локальну мережу і віддалений сервер, тільки тепер у локального ПК є доступ до Інтернету через NAT. Припустимо, що системному адміністратору, який має фізичний доступ до віддаленого сервера, потрібно підключитися по RDP до комп\u0026rsquo;ютера 192.168.0.2, але NAT не дасть цього зробити безпосередньо.\nРозглянемо приклад, де існує RDP сервіс, що за змовчанням запущено на локальному порту 3389. Прокидаємо його на віддалений порт 3333.\nssh -f -N -R 3333:127.0.0.1:3389 username@212.212.212.212 Після підняття такого тунелю, сисадмін, що сидить за віддаленим сервером, зможе до нас підключитися RDP, використовуючи в RDP клієнті адресу 127.0.0.1:3333.\nВисновки Ось такі прості прийоми тунелювання через SSH протокол дозволяють маючи в розпорядженні доступ по SSH, перенаправляти порти локального чи віддаленого сервісу як заманеться, що може стати в нагоді якщо треба обійти певні обмеження в мережі, як, наприклад NAT.\n","date":"2016-09-26T00:00:00Z","image":"https://blog.moroz.cc/uk/post/%D0%BF%D0%B5%D1%80%D0%B5%D0%BD%D0%B0%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%BD%D1%8F-%D0%BF%D0%BE%D1%80%D1%82%D1%96%D0%B2-%D0%B7%D0%B0-%D0%B4%D0%BE%D0%BF%D0%BE%D0%BC%D0%BE%D0%B3%D0%BE%D1%8E-ssh-%D1%82%D1%83%D0%BD%D0%B5%D0%BB%D1%8E/header_hu9370f1f3ff0baab462d9f98d73fd8fc5_63678_120x120_fill_q75_h2_box_smart1_2.webp","permalink":"https://blog.moroz.cc/uk/post/%D0%BF%D0%B5%D1%80%D0%B5%D0%BD%D0%B0%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%BD%D1%8F-%D0%BF%D0%BE%D1%80%D1%82%D1%96%D0%B2-%D0%B7%D0%B0-%D0%B4%D0%BE%D0%BF%D0%BE%D0%BC%D0%BE%D0%B3%D0%BE%D1%8E-ssh-%D1%82%D1%83%D0%BD%D0%B5%D0%BB%D1%8E/","title":"Перенаправлення портів за допомогою SSH тунелю"}]