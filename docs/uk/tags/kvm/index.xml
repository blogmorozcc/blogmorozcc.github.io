<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>KVM on Блог про IT</title>
        <link>https://blog.moroz.cc/uk/tags/kvm/</link>
        <description>Recent content in KVM on Блог про IT</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>uk</language>
        <lastBuildDate>Sat, 01 Jun 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.moroz.cc/uk/tags/kvm/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>Запуск Stable Diffusion у віртуальній машині на відеокарті AMD (AUTOMATIC1111 &#43; KVM &#43; GPU Passthrough)</title>
        <link>https://blog.moroz.cc/uk/post/%D0%B7%D0%B0%D0%BF%D1%83%D1%81%D0%BA-stable-diffusion-%D1%83-%D0%B2%D1%96%D1%80%D1%82%D1%83%D0%B0%D0%BB%D1%8C%D0%BD%D1%96%D0%B9-%D0%BC%D0%B0%D1%88%D0%B8%D0%BD%D1%96-%D0%BD%D0%B0-%D0%B2%D1%96%D0%B4%D0%B5%D0%BE%D0%BA%D0%B0%D1%80%D1%82%D1%96-amd-automatic1111--kvm--gpu-passthrough/</link>
        <pubDate>Sat, 01 Jun 2024 00:00:00 +0000</pubDate>
        
        <guid>https://blog.moroz.cc/uk/post/%D0%B7%D0%B0%D0%BF%D1%83%D1%81%D0%BA-stable-diffusion-%D1%83-%D0%B2%D1%96%D1%80%D1%82%D1%83%D0%B0%D0%BB%D1%8C%D0%BD%D1%96%D0%B9-%D0%BC%D0%B0%D1%88%D0%B8%D0%BD%D1%96-%D0%BD%D0%B0-%D0%B2%D1%96%D0%B4%D0%B5%D0%BE%D0%BA%D0%B0%D1%80%D1%82%D1%96-amd-automatic1111--kvm--gpu-passthrough/</guid>
        <description>&lt;img src="https://blog.moroz.cc/post/how-to-run-stable-diffusion-in-vm-on-amd-gpu-automatic1111--kvm--gpu-passthrough/header.png" alt="Featured image of post Запуск Stable Diffusion у віртуальній машині на відеокарті AMD (AUTOMATIC1111 &#43; KVM &#43; GPU Passthrough)" /&gt;&lt;h2 id=&#34;вступ&#34;&gt;Вступ&lt;/h2&gt;
&lt;p&gt;Stable Diffusion — це модель глибокого навчання з текстом у зображення, розроблена Stability AI, що використовується для створення детальних зображень на основі текстових підказок. Модель належить до класу генеративних моделей, званих дифузійними моделями, які ітеративно знімають шум у випадковому сигналі для отримання зображення. AUTOMATIC1111 відноситься до популярної реалізації веб-інтерфейсу користувача (UI) для взаємодії із Stable Diffusion. Він забезпечує надійний і зручний спосіб використання можливостей Stable Diffusion.&lt;/p&gt;
&lt;h3 id=&#34;чому-я-запускаю-automatic1111-у-віртуальній-машині&#34;&gt;Чому я запускаю AUTOMATIC1111 у віртуальній машині&lt;/h3&gt;
&lt;p&gt;В одній із моїх попередніх статей я згадав, що використовую ПК з двома відеокартами AMD, використовує Arch Linux в якості основної ОС. Особисто для мене запуск AUTOMATIC1111 у віртуальній машині на базі KVM із прокиданням відеокарти AMD має кілька ключових переваг:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Портативність&lt;/strong&gt;. Оскільки я використовую Arch Linux як свою основну хост-ОС на різних комп’ютерах, інколи буває складно керувати залежностями, необхідними для запуску AUTOMATIC1111. Наприклад, на момент написання цієї статті (02.06.2024) для AUTOMATIC1111 потрібен Python 3.10, а найновішою версією Python в офіційних репозиторіях arch є Python 3.12. У разі запуску AUTOMATIC1111 усередині віртуальної машини я можу налаштувати залежності всередині цієї віртуальної машини, і мені не потрібно турбуватися про те, що залежності потенційно стануть некоректними після оновлення Arch.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Резервне копіювання&lt;/strong&gt;. Оскільки я маю сховище віртуальної машини як один файл *.qcow2, я можу створити його резервну копію, перенести на іншу машину чи сервер у своїй домашній лабораторії. Також легко зберігати файли AI моделей та LORA в cховищі віртуальної машини, і якщо мені потрібно перенести інсталяцію AUTOMATIC1111 на іншу реальну машину, мені потрібно лише скопіювати резервну копію віртуальної машини. Немає необхідності кожного разу встановлювати залежності, налаштовувати моделі.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;для-чого-мені-потрібен-automatic1111&#34;&gt;Для чого мені потрібен AUTOMATIC1111&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/ShiftHackZ/Stable-Diffusion-Android/raw/master/docs/assets/github-header-image.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;Програмне забезпечення AUTOMATIC1111 дуже важливе для моєї роботи, оскільки я розробляю безкоштовний open soruce додаток &lt;a class=&#34;link&#34; href=&#34;https://github.com/ShiftHackZ/Stable-Diffusion-Android&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;SDAI - Android Stable Diffusion&lt;/a&gt;, який можна підключати до будь-якого сервера AUTOMATIC1111 або іншого підтримуваного провайдера генерації зображень. Мені потрібно багато різних ізольованих віртуальних серверів AUTOMATIC1111 для тестування мого Android додатку.&lt;/p&gt;
&lt;h2 id=&#34;встановлення&#34;&gt;Встановлення&lt;/h2&gt;
&lt;h3 id=&#34;створення-нової-віртуальної-машини-linux&#34;&gt;Створення нової віртуальної машини Linux&lt;/h3&gt;
&lt;p&gt;Спочатку нам потрібно створити нову віртуальну машину Linux із пропуском GPU пристроїв PCI до цієї віртуальної машини. Я вже розповідав про створення віртуальної машини в статті &amp;ldquo;&lt;a class=&#34;link&#34; href=&#34;https://blog.moroz.cc/uk/post/%d0%bf%d1%80%d0%be%d0%ba%d0%b8%d0%b4%d0%b0%d0%bd%d0%bd%d1%8f-%d0%b2%d1%96%d0%b4%d0%b5%d0%be%d0%ba%d0%b0%d1%80%d1%82%d0%b8-pci-%d0%b4%d0%be-windows-kvm-%d0%bd%d0%b0-arch-linux/#%d0%bd%d0%b0%d0%bb%d0%b0%d1%88%d1%82%d1%83%d0%b2%d0%b0%d0%bd%d0%bd%d1%8f-%d0%bd%d0%be%d0%b2%d0%be%d1%97-%d0%b2%d1%96%d1%80%d1%82%d1%83%d0%b0%d0%bb%d1%8c%d0%bd%d0%be%d1%97-%d0%bc%d0%b0%d1%88%d0%b8%d0%bd%d0%b8-%d1%82%d0%b0-%d1%83%d1%81%d1%82%d0%b0%d0%bd%d0%be%d0%b2%d0%ba%d0%b0-windows-1011&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;GPU PCI passthrough to Windows KVM on Arch Linux&lt;/a&gt;&amp;rdquo;, але цього разу я використовуватиму &lt;a class=&#34;link&#34; href=&#34;https://releases.ubuntu.com/22.04/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Ubuntu Sever 22.04 LTS&lt;/a&gt; як ОС для гостьової ВМ. Я вибрав Ubuntu Server 22.04 для гостьової ОС, тому що на момент написання цієї статті (02.06.2024) це остання версія, яка підтримується пропрієтарним драйвером AMD ROCM, який необхідний для запуску штучного інтелекту на потужності GPU.&lt;/p&gt;
&lt;h3 id=&#34;оновіть-пакети-ос&#34;&gt;Оновіть пакети ОС&lt;/h3&gt;
&lt;p&gt;Після встановлення ОС перше, що вам потрібно зробити, це оновити системні пакети до останніх доступних версій.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo apt update
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo apt upgrade
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;встановіть-необхідні-пакети&#34;&gt;Встановіть необхідні пакети&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo apt install -y git python3-pip python3-venv python3-dev libstdc++-12-dev libgl1-mesa-glx&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;встановлення-драйвера-amd-rocm&#34;&gt;Встановлення драйвера AMD ROCM&lt;/h3&gt;
&lt;p&gt;Я використав офіційні інструкції з &lt;a class=&#34;link&#34; href=&#34;https://rocm.docs.amd.com/projects/install-on-linux/en/latest/tutorial/quick-start.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;документації AMD&lt;/a&gt;, щоб встановити драйвер ROCM.&lt;/p&gt;
&lt;p&gt;Спочатку встановіть заголовки та додаткові компоненти для поточного ядра:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo apt install -y &lt;span class=&#34;s2&#34;&gt;&amp;#34;linux-headers-&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;uname -r&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;linux-modules-extra-&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;uname -r&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Потім переконайтеся, що ваш поточний користувач включений до груп &lt;code&gt;video&lt;/code&gt; і &lt;code&gt;render&lt;/code&gt;. Щоб додати поточного користувача до груп, використовуйте команду:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo usermod -a -G render,video &lt;span class=&#34;nv&#34;&gt;$LOGNAME&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Завантажте інсталяційний пакет deb і встановіть його:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;wget https://repo.radeon.com/amdgpu-install/6.1.1/ubuntu/jammy/amdgpu-install_6.1.60101-1_all.deb
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo dpkg -i amdgpu-install_6.1.60101-1_all.deb&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Встановіть модуль DKMS і пакети rocm:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo apt update
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo apt install amdgpu-dkms rocm&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Нарешті, перезавантажте віртуальну машину:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo reboot&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;встановлення-automatic1111&#34;&gt;Встановлення AUTOMATIC1111&lt;/h3&gt;
&lt;p&gt;Найпростіший і зручний спосіб - просто клонувати офіційний репозиторій git. Після клонування перейдіть до клонованого каталогу.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;git clone https://github.com/AUTOMATIC1111/stable-diffusion-webui
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;cd&lt;/span&gt; stable-diffusion-webui&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Налаштуйте віртуальне середовище Python:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;python3 -m venv venv
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;source&lt;/span&gt; venv/bin/activate&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Встановіть залежності python, необхідні AUTOMATIC1111:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;pip3 install -r requirements.txt&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Видаліть стандартні залежності torch та замініть їх на ROCM:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;pip3 uninstall torch torchvision
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;pip3 install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/rocm6.0&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;створіть-скрипт-запуску-automatic1111&#34;&gt;Створіть скрипт запуску AUTOMATIC1111&lt;/h3&gt;
&lt;p&gt;Я буду використовувати nano для створення нового файлу &lt;code&gt;nano launch.sh&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#!/bin/sh
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;source&lt;/span&gt; venv/bin/activate
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;HSA_OVERRIDE_GFX_VERSION&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;10.3.0
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;HIP_VISIBLE_DEVICES&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;PYTORCH_HIP_ALLOC_CONF&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;garbage_collection_threshold:0.8,max_split_size_mb:512
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;python3 launch.py --api --listen --enable-insecure-extension-access --opt-sdp-attention
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;Потім збережіть файл &lt;code&gt;Ctrl + O&lt;/code&gt; і вийдіть з nano &lt;code&gt;Ctrl + X&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&#34;запуск-automatic1111&#34;&gt;Запуск AUTOMATIC1111&lt;/h3&gt;
&lt;p&gt;Кожного разу, коли вам потрібно запустити AUTOMATIC1111, перейдіть до склонованого каталогу &lt;code&gt;stable-diffusion-webui&lt;/code&gt; і запустіть створений сценарій &lt;code&gt;launch.sh&lt;/code&gt;, як у наступному прикладі:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;cd&lt;/span&gt; stable-diffusion-webui
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;bash launch.sh&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;У результаті ви побачите, що AUTOMATIC1111 працює.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.moroz.cc/post/how-to-run-stable-diffusion-in-vm-on-amd-gpu-automatic1111--kvm--gpu-passthrough/a1111-launch.png&#34;
	width=&#34;1047&#34;
	height=&#34;395&#34;
	srcset=&#34;https://blog.moroz.cc/post/how-to-run-stable-diffusion-in-vm-on-amd-gpu-automatic1111--kvm--gpu-passthrough/a1111-launch_hu133252618004603506.png 480w, https://blog.moroz.cc/post/how-to-run-stable-diffusion-in-vm-on-amd-gpu-automatic1111--kvm--gpu-passthrough/a1111-launch_hu17688080236442681459.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;Запущений інстанс AUTOMATIC1111.&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;265&#34;
		data-flex-basis=&#34;636px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;висновок&#34;&gt;Висновок&lt;/h2&gt;
&lt;p&gt;Stable Diffusion — це потужна модель для створення зображень із текстових описів, а AUTOMATIC1111 — це зручний інтерфейс, який полегшує ефективне використання можливостей Stable Diffusion. Разом вони забезпечують широкий спектр творчих і практичних застосувань у сфері генеративного мистецтва та синтезу зображень. Використовуючи віртуальну машину на основі KVM із прокинутим графічним адаптером AMD, ви можете створити потужне, безпечне та гнучке середовище для запуску AUTOMATIC1111 і ефективного використання можливостей Stable Diffusion.&lt;/p&gt;
&lt;h2 id=&#34;посилання&#34;&gt;Посилання&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://releases.ubuntu.com/22.04/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Ubuntu Sever 22.04 LTS Jammy&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://rocm.docs.amd.com/projects/install-on-linux/en/latest/tutorial/quick-start.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;AMD ROCM Документація&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/AUTOMATIC1111/stable-diffusion-webui&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;AUTOMATIC1111&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/ShiftHackZ/Stable-Diffusion-Android&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;SDAI - Stable Diffusion Android додаток&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://gist.github.com/evshiron/8cf4de34aa01e217ce178b8ed54a2c43&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Кастомний скрипт запуску stable-diffusion-webui&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>Виготовлення пристрою PiKVM v2 для віддаленого керування комп’ютером або сервером (KVM через IP)</title>
        <link>https://blog.moroz.cc/uk/post/%D0%B2%D0%B8%D0%B3%D0%BE%D1%82%D0%BE%D0%B2%D0%BB%D0%B5%D0%BD%D0%BD%D1%8F-%D0%BF%D1%80%D0%B8%D1%81%D1%82%D1%80%D0%BE%D1%8E-pikvm-v2-%D0%B4%D0%BB%D1%8F-%D0%B2%D1%96%D0%B4%D0%B4%D0%B0%D0%BB%D0%B5%D0%BD%D0%BE%D0%B3%D0%BE-%D0%BA%D0%B5%D1%80%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F-%D0%BA%D0%BE%D0%BC%D0%BF%D1%8E%D1%82%D0%B5%D1%80%D0%BE%D0%BC-%D0%B0%D0%B1%D0%BE-%D1%81%D0%B5%D1%80%D0%B2%D0%B5%D1%80%D0%BE%D0%BC-kvm-%D1%87%D0%B5%D1%80%D0%B5%D0%B7-ip/</link>
        <pubDate>Fri, 29 Mar 2024 00:00:00 +0000</pubDate>
        
        <guid>https://blog.moroz.cc/uk/post/%D0%B2%D0%B8%D0%B3%D0%BE%D1%82%D0%BE%D0%B2%D0%BB%D0%B5%D0%BD%D0%BD%D1%8F-%D0%BF%D1%80%D0%B8%D1%81%D1%82%D1%80%D0%BE%D1%8E-pikvm-v2-%D0%B4%D0%BB%D1%8F-%D0%B2%D1%96%D0%B4%D0%B4%D0%B0%D0%BB%D0%B5%D0%BD%D0%BE%D0%B3%D0%BE-%D0%BA%D0%B5%D1%80%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F-%D0%BA%D0%BE%D0%BC%D0%BF%D1%8E%D1%82%D0%B5%D1%80%D0%BE%D0%BC-%D0%B0%D0%B1%D0%BE-%D1%81%D0%B5%D1%80%D0%B2%D0%B5%D1%80%D0%BE%D0%BC-kvm-%D1%87%D0%B5%D1%80%D0%B5%D0%B7-ip/</guid>
        <description>&lt;img src="https://blog.moroz.cc/post/assembling-a-pikvm-v2-device-for-remote-kvm-over-ip-control-of-a-computer-or-server/header.jpg" alt="Featured image of post Виготовлення пристрою PiKVM v2 для віддаленого керування комп’ютером або сервером (KVM через IP)" /&gt;&lt;h2 id=&#34;ознайомлення-з-kvm-через-ip&#34;&gt;Ознайомлення з KVM через IP&lt;/h2&gt;
&lt;p&gt;KVM через IP (клавіатура, відео, миша через IP) — це технологія, яка забезпечує віддалений доступ і керування комп’ютером або сервером через мережеве з’єднання. Це дозволяє користувачам керувати сервером або ПК так, ніби вони фізично присутні біля машини, незалежно від їхнього розташування.&lt;/p&gt;
&lt;h3 id=&#34;принцип-роботи&#34;&gt;Принцип роботи&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Апаратний пристрій&lt;/strong&gt;: KVM через IP являя собою апаратний пристрій, встановлений на сервері або інтегрований у апаратне забезпечення сервера. Цей пристрій підключається до портів клавіатури, відео та миші сервера.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Мережеве підключення&lt;/strong&gt;: потім пристрій KVM через IP підключається до мережі інтернет, що забезпечує віддалений доступ до сервера.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Програмне забезпечення для доступу&lt;/strong&gt;: користувачі можуть отримати віддалений доступ до консолі сервера за допомогою спеціального програмного забезпечення, наданого виробником пристрою KVM через IP. Це програмне забезпечення дозволяє користувачам переглядати екран сервера, керувати введенням даних з клавіатури та миші та взаємодіяти з сервером так, ніби вони фізично присутні.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Функції безпеки&lt;/strong&gt;: рішення KVM через IP часто мають такі функції безпеки, як шифрування та автентифікація, щоб забезпечити безпечний віддалений доступ до сервера.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;переваги-kvm-над-програмним-забезпеченням-віддаленого-робочого-столу&#34;&gt;Переваги KVM над програмним забезпеченням віддаленого робочого столу&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Доступ низького рівня&lt;/strong&gt;: KVM через IP забезпечує доступ низького рівня до сервера, дозволяючи користувачам взаємодіяти з сервером або ПК на рівні BIOS та під час процесу завантаження. Цей рівень доступу зазвичай недоступний для програмних рішень для віддаленого робочого столу, які працюють у середовищі операційної системи.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Незалежність від операційної системи&lt;/strong&gt;: оскільки KVM через IP працює на апаратному рівні, такі апаратні засоби не залежить від операційної системи сервера. Це означає, що його можна використовувати для усунення несправностей і керування серверами та ПК, навіть якщо операційна система не відповідає або не працює.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Управління поза діапазоном&lt;/strong&gt;: KVM через IP забезпечує можливості керування поза діапазоном, дозволяючи адміністраторам отримувати віддалений доступ і керувати серверами, навіть якщо мережа або операційна система не працює. Це може бути вирішальним для завдань з усунення несправностей і обслуговування.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Продуктивність&lt;/strong&gt;: рішення KVM через IP часто забезпечують кращу продуктивність порівняно з програмними рішеннями для віддаленого робочого столу, особливо для завдань, які вимагають низької затримки та високої роздільної здатності.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Встановлення програмного забезпечення не вимагається&lt;/strong&gt;: оскільки KVM через IP є апаратним рішенням, воно не потребує встановлення програмного забезпечення на стороні сервера, що може спростити розгортання та обслуговування.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;огляд-апаратних-рішень&#34;&gt;Огляд апаратних рішень&lt;/h2&gt;
&lt;h3 id=&#34;промислові-перемикачі-kvm&#34;&gt;Промислові перемикачі KVM&lt;/h3&gt;
&lt;p&gt;На ринку доступно багато пристроїв KMV через IP, але вони мають деякі недоліки, якщо вам потрібне доступне рішення для особистого використання, яке включає такі ключові моменти:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Вартість&lt;/strong&gt;: промислові апаратні рішення KVM зазвичай передбачають вищі витрати порівняно з рішеннями з відкритим кодом, оскільки вони часто мають додаткові функції та послуги підтримки.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Пропрієтарне програмне забезпечення&lt;/strong&gt;: більшість KVM-перемикачів, які виготовляються для виробничого використання в серверних кімнатах і центрах обробки даних критичної інфраструктури, постачаються в комплекті з програмним забезпеченням із закритим вихідним кодом, яке має власну ліцензію.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;pikvm&#34;&gt;PiKVM&lt;/h3&gt;
&lt;p&gt;Найкращим рішенням для персональної домашньої серверної лабораторії або віддаленого керування ПК чи ноутбуком є &lt;a class=&#34;link&#34; href=&#34;https://pikvm.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;PiKVM&lt;/a&gt; – недороге рішення IP-KVM з відкритим вихідним кодом на основі одноплатного ARM комп’ютера &lt;a class=&#34;link&#34; href=&#34;https://www.raspberrypi.com/products/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Raspberry Pi&lt;/a&gt; .&lt;/p&gt;
&lt;p&gt;Пристрій &lt;a class=&#34;link&#34; href=&#34;https://pikvm.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;PiKVM&lt;/a&gt; має багато корисних функцій для керування віддаленою машиною, наприклад:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Симуляція дисків: це дозволяє прикріпити локальний файл *.iso до віддаленої машини, це дозволяє віддалено переінсталювати будь-яку ОС.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Імітація підключення/відключення USB периферії.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Контроль живленням ATX.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Якщо ви хочете стати власником пристрою &lt;a class=&#34;link&#34; href=&#34;https://pikvm.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;PiKVM&lt;/a&gt;, то для вас існує 2 варіанти:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Замовити готовий пристрій на офіційному сайті.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Придбайте одну з &lt;a class=&#34;link&#34; href=&#34;https://docs.pikvm.org/v2/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;підтримуваних&lt;/a&gt; плат Raspberry Pi, а також необхідні електронні компоненти та зберіть пристрій своїми руками.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;створення-власного-пристрою-pikvm-v2&#34;&gt;Створення власного пристрою PiKVM v2&lt;/h2&gt;
&lt;p&gt;Я вирішив самостійно створити пристрій PiKVM v2, оскільки для моєї країни немає варіантів доставки готових пристроїв. Крім того, збірка своїми руками дає більше гнучкості: можена створити пристрій відповідно до необхідних функцій, при цьоми обирати будь-які компоненти за власним бажанням.&lt;/p&gt;
&lt;h3 id=&#34;вибір-компонентів&#34;&gt;Вибір компонентів&lt;/h3&gt;
&lt;p&gt;Після вивчення офіційної документації PiKVM стає очевидним, що найкращою версією для збірки є PiKVM v2. Для виготовлення свого пристрою я використовував такі апаратні компоненти:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1 x &lt;a class=&#34;link&#34; href=&#34;https://www.raspberrypi.com/products/raspberry-pi-4-model-b/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Raspberry Pi 4 Model B&lt;/a&gt; з 2 Гб оперативної пам&amp;rsquo;яті.&lt;/li&gt;
&lt;li&gt;1 x &lt;a class=&#34;link&#34; href=&#34;https://prom.ua/ua/p2056074929-blok-zhivlennya-gan.html?product_id=2056074929&amp;amp;category_ids=71109&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Блок живлення GAN 65W PD&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;1 x &lt;a class=&#34;link&#34; href=&#34;https://www.aliexpress.com/item/1005001880861192.html?spm=a2g0o.order_list.order_list_main.11.6b4f1802HEgPtC&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;HDMI USB карта захоплення відео&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;1 x Kingston SD картка пам&amp;rsquo;яті на 32 Gb 10-го класу.&lt;/li&gt;
&lt;li&gt;2 x USB-A до USB-C кабелі (для виготовлення спеціального кабелю живлення).&lt;/li&gt;
&lt;li&gt;1 X HDMI кабель.&lt;/li&gt;
&lt;li&gt;1 x 80мм вентилятор (для активного охолодження).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.moroz.cc/post/assembling-a-pikvm-v2-device-for-remote-kvm-over-ip-control-of-a-computer-or-server/img/IMG_20240330_172625_917.jpg&#34;
	width=&#34;2393&#34;
	height=&#34;1639&#34;
	srcset=&#34;https://blog.moroz.cc/post/assembling-a-pikvm-v2-device-for-remote-kvm-over-ip-control-of-a-computer-or-server/img/IMG_20240330_172625_917_hu521897210767238446.jpg 480w, https://blog.moroz.cc/post/assembling-a-pikvm-v2-device-for-remote-kvm-over-ip-control-of-a-computer-or-server/img/IMG_20240330_172625_917_hu8442927147312641795.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;Комплектуючі необхідні для PiKVM.&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;146&#34;
		data-flex-basis=&#34;350px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;виготовлення-спеціального-кабелю-живлення&#34;&gt;Виготовлення спеціального кабелю живлення&lt;/h3&gt;
&lt;p&gt;Щоб мати можливість керувати віддаленим комп’ютером через саморобний KVM пристрій, комп’ютер повинен розпізнавати наш пристрій як HID USB-пристрій, який сприйматиметься комп’ютером так само, як нібито це інша клавіатура чи миша (комп’ютерна клавіатура та миша також є HID-пристроями).&lt;/p&gt;
&lt;p&gt;Але плата Raspberry Pi 4 Model B має критичний недлоік – вона має лише один порт USB-C, який може працювати як пристрій HID, і цей порт також використовується для живлення пристрою. Щоб виправити таке функціональне обмеження, треба виготовити спеціальний кабель, що може одночасно працювати як USB-пристрій для цільового хоста та отримувати зовнішнє живлення від адаптера живлення.&lt;/p&gt;
&lt;p&gt;Щоб виготовити такий нестандартний кабель живлення, вам знадобляться 2 кабелі &lt;strong&gt;USB-A male до USB-C male&lt;/strong&gt;. Я рекомендую вибирати якісні кабелі, тому що для живлення плати сила струму становить 3А. Процес виготовлення кабелю включає наступні етапи:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Візьміть перший кабель і зріжте ізоляцію. Залиште дроти лінії передачі даних (зелений і білий) як є та відріжте дроти живлення +5В (червоний) і землю (чорний).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Візьміть другий кабель і відріжте його повністю. Нам потрібна лише частина USB-A.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Припаяйте провід живлення +5В (червоний) другої частини кабелю USB-A, до проводу живлення +5В (червоний) частини кабелю USB-C.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Припаяйте разом усі 3 заземлюючі (чорні) дроти всіх частин кабелю.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Ретельно ізолюйте всі контакти.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Таким чином, роз’єм USB-C слід під’єднати до плати Raspberry Pi, роз’єм USB-A другого кабелю (того, до якого підключено живлення) слід під’єднати до адаптера живлення, а роз’єм USB-A першого кабелю (того, з дроти даних) слід підключити до ПК, яким ви хочете керувати. Для кращого розуміння нижче наведена схема пайки кабелю.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.moroz.cc/post/assembling-a-pikvm-v2-device-for-remote-kvm-over-ip-control-of-a-computer-or-server/v2_splitter_soldering.png&#34;
	width=&#34;977&#34;
	height=&#34;485&#34;
	srcset=&#34;https://blog.moroz.cc/post/assembling-a-pikvm-v2-device-for-remote-kvm-over-ip-control-of-a-computer-or-server/v2_splitter_soldering_hu4849882703031444457.png 480w, https://blog.moroz.cc/post/assembling-a-pikvm-v2-device-for-remote-kvm-over-ip-control-of-a-computer-or-server/v2_splitter_soldering_hu8442061173123843600.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;Схема підключення роз&amp;rsquo;ємів спеціального кабелю живлення PiKVM v2.&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;201&#34;
		data-flex-basis=&#34;483px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;Також я рекомендую це відео на YouTube від розробника PiKVM, яке пояснює повний процес виготовлення цього спеціального кабелю.&lt;/p&gt;
&lt;div class=&#34;video-wrapper&#34;&gt;
    &lt;iframe loading=&#34;lazy&#34; 
            src=&#34;https://www.youtube.com/embed/uLuBuQUF61o&#34; 
            allowfullscreen 
            title=&#34;YouTube Video&#34;
    &gt;
    &lt;/iframe&gt;
&lt;/div&gt;

&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;Ось фото кабелю, що вийшов у мене. Я позначив усі сторони кабелю, щоб уникнути плутанини роз&amp;rsquo;ємів під час підключення обладнання. Чорний кабель USB-A повинен підключатися до адаптера живлення, білий кабель USB-A — до комп’ютера, а роз’єм USB-C — для плати Raspberry Pi.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.moroz.cc/post/assembling-a-pikvm-v2-device-for-remote-kvm-over-ip-control-of-a-computer-or-server/img/IMG_11.jpg&#34;
	width=&#34;1880&#34;
	height=&#34;2566&#34;
	srcset=&#34;https://blog.moroz.cc/post/assembling-a-pikvm-v2-device-for-remote-kvm-over-ip-control-of-a-computer-or-server/img/IMG_11_hu2026414388001268328.jpg 480w, https://blog.moroz.cc/post/assembling-a-pikvm-v2-device-for-remote-kvm-over-ip-control-of-a-computer-or-server/img/IMG_11_hu16173094001219447609.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;Фінальний вигляд кастомного кабелю живлення.&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;73&#34;
		data-flex-basis=&#34;175px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;збірка-пристрою-в-саморобному-корпусі&#34;&gt;Збірка пристрою в саморобному корпусі&lt;/h3&gt;
&lt;p&gt;Компоненти, які я використовую для створення пристрою, включають зовнішню плату захоплення відеосигналу HDMI, яку слід підключити до конкретного USB-порту плати Raspberry Pi. Для моїх потреб пристрій має бути портативним. Враховуючи це, офіційний корпус для Raspberry Pi дуже підходить, до того ж він коштує занадто дорого, на мій погляд. Тож я вирішив повністю зібрати пристрій та всі електронні компоненти в одному корпусі для кращої портативності. Кожен раз, коли мені потрібно використовувати його з іншим ПК, мені просто потрібно підключити до нього кабелі HDMI та USB.&lt;/p&gt;
&lt;p&gt;Також не секрет, що плати Rasperry Pi можуть перегріватися під час роботи в умовах екстремального навантаження на процесор або в умовах безперервної роботи 24/7. Беручи це до уваги, я вирішив сконструювати корпус таким чином, щоб усе обладнання охолоджувалося вентилятором 80мм.&lt;/p&gt;
&lt;p&gt;На жаль, у мене немає 3D-принтера, щоб спроектувати та створити якісний корпус, що мав би вигляд як у промислового пристрою. Мій корпус повністю ручної роботи. Я використовував переважно деякі старі пластикові панелі, що залишилися в мене після ремонту.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.moroz.cc/post/assembling-a-pikvm-v2-device-for-remote-kvm-over-ip-control-of-a-computer-or-server/img/IMG_15.jpg&#34;
	width=&#34;2566&#34;
	height=&#34;1736&#34;
	srcset=&#34;https://blog.moroz.cc/post/assembling-a-pikvm-v2-device-for-remote-kvm-over-ip-control-of-a-computer-or-server/img/IMG_15_hu5430315393519054372.jpg 480w, https://blog.moroz.cc/post/assembling-a-pikvm-v2-device-for-remote-kvm-over-ip-control-of-a-computer-or-server/img/IMG_15_hu5048984929459482917.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;PiKVM v2 пристрій зібраний в саморобному корпусі з пластикових панелей.&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;147&#34;
		data-flex-basis=&#34;354px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.moroz.cc/post/assembling-a-pikvm-v2-device-for-remote-kvm-over-ip-control-of-a-computer-or-server/img/IMG_12.jpg&#34;
	width=&#34;2652&#34;
	height=&#34;1143&#34;
	srcset=&#34;https://blog.moroz.cc/post/assembling-a-pikvm-v2-device-for-remote-kvm-over-ip-control-of-a-computer-or-server/img/IMG_12_hu4437620323459149077.jpg 480w, https://blog.moroz.cc/post/assembling-a-pikvm-v2-device-for-remote-kvm-over-ip-control-of-a-computer-or-server/img/IMG_12_hu4141037336672872349.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;Внутрішнє оснащення та розташування електронних компонентів саморобного пристрою PiKVM v2.&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;232&#34;
		data-flex-basis=&#34;556px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;Вентилятор можна підключити до відповідних контактів GPIO на платі. Для цього я використав контакт №2 для +5В (червоний дріт) і контакт №6 для мінусу (чорний дріт) живлення вентилятора.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.moroz.cc/post/assembling-a-pikvm-v2-device-for-remote-kvm-over-ip-control-of-a-computer-or-server/GPIO-Pinout-Diagram-2.png&#34;
	width=&#34;2064&#34;
	height=&#34;1185&#34;
	srcset=&#34;https://blog.moroz.cc/post/assembling-a-pikvm-v2-device-for-remote-kvm-over-ip-control-of-a-computer-or-server/GPIO-Pinout-Diagram-2_hu6469622565292939902.png 480w, https://blog.moroz.cc/post/assembling-a-pikvm-v2-device-for-remote-kvm-over-ip-control-of-a-computer-or-server/GPIO-Pinout-Diagram-2_hu8493741587978962470.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;Схема GPIO розпіновки плати Raspberry Pi 4 Model B.&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;174&#34;
		data-flex-basis=&#34;418px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;Я використовував роз’єм що вже був у вентилятора, але мені довелося перепінувати контакти на цьому роз’ємі в правильному порядку.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.moroz.cc/post/assembling-a-pikvm-v2-device-for-remote-kvm-over-ip-control-of-a-computer-or-server/img/IMG_13.jpg&#34;
	width=&#34;2540&#34;
	height=&#34;1896&#34;
	srcset=&#34;https://blog.moroz.cc/post/assembling-a-pikvm-v2-device-for-remote-kvm-over-ip-control-of-a-computer-or-server/img/IMG_13_hu12008510141273031739.jpg 480w, https://blog.moroz.cc/post/assembling-a-pikvm-v2-device-for-remote-kvm-over-ip-control-of-a-computer-or-server/img/IMG_13_hu17939192236510261296.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;Підключення вентилятора до плати Raspberry Pi використовуючи GPIO інтерфейс.&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;133&#34;
		data-flex-basis=&#34;321px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;Також я вирішив додатково винести порт RJ-45 Ethernet збоку, тому що при використання кабельного підключення до мережі інтернет якість потокового відео краща, а затримка менша на відміну від підключення черех Wi-Fi. Для цього я зробив спеціальний подовжувач кабелю та встановив порт біля порту HDMI.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.moroz.cc/post/assembling-a-pikvm-v2-device-for-remote-kvm-over-ip-control-of-a-computer-or-server/img/IMG_14.jpg&#34;
	width=&#34;2106&#34;
	height=&#34;1810&#34;
	srcset=&#34;https://blog.moroz.cc/post/assembling-a-pikvm-v2-device-for-remote-kvm-over-ip-control-of-a-computer-or-server/img/IMG_14_hu8701258946247665887.jpg 480w, https://blog.moroz.cc/post/assembling-a-pikvm-v2-device-for-remote-kvm-over-ip-control-of-a-computer-or-server/img/IMG_14_hu1196213390416759870.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;Порти Ethernet RJ-45 та вхід HDMI змонтовані збоку пристрою.&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;116&#34;
		data-flex-basis=&#34;279px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;прошивка-pikvm-os&#34;&gt;Прошивка PiKVM OS&lt;/h3&gt;
&lt;p&gt;Для того, щоб Raspberry Pi міг діяти як апаратний KVM-пристрій, слід записати на SD-карту образ операційної системи з відкритим вихідним кодом  PiKVM.&lt;/p&gt;
&lt;p&gt;Правильний образ PiKVM, який підходить для конкретної моделі Raspberry Pi, можна знайти на сторінці &lt;a class=&#34;link&#34; href=&#34;https://docs.pikvm.org/flashing_os/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;PiKVM Flashing OS&lt;/a&gt;. У моєму випадку я завантажив образ платформи DIY PiKVM V2, Raspberry Pi 4 що запрограмовано для використання з HDMI-USB картою захоплення. Образ повністю відповідає апаратному забезпеченню, яке я використовував (Raspblerry Pi 4 Model B і USB карта захоплення відео).&lt;/p&gt;
&lt;p&gt;Щоб записани образ ОС на SD-карту, існує програмне забезпечення &lt;a class=&#34;link&#34; href=&#34;https://github.com/raspberrypi/rpi-imager&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;RPI Imager&lt;/a&gt;. Оскільки я використовую Arch Linux, я встановив його з офіційного пакета &lt;a class=&#34;link&#34; href=&#34;https://archlinux.org/packages/extra/x86_64/rpi-imager/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;rpi-imager&lt;/a&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo pacman -S rpi-imager&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Потім слід підключити SD-карту до комп’ютера. Оскільки мій комп’ютер не має вбудованого кард-рідера, я використовую адаптер micro-SD до USB-A.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.moroz.cc/post/assembling-a-pikvm-v2-device-for-remote-kvm-over-ip-control-of-a-computer-or-server/img/IMG_10.jpg&#34;
	width=&#34;1864&#34;
	height=&#34;1310&#34;
	srcset=&#34;https://blog.moroz.cc/post/assembling-a-pikvm-v2-device-for-remote-kvm-over-ip-control-of-a-computer-or-server/img/IMG_10_hu14983050107056658618.jpg 480w, https://blog.moroz.cc/post/assembling-a-pikvm-v2-device-for-remote-kvm-over-ip-control-of-a-computer-or-server/img/IMG_10_hu16266499531716359489.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;Адаптер Micro-SD до USB-A.&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;142&#34;
		data-flex-basis=&#34;341px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;Щоб записати образ на картку пам&amp;rsquo;яті, виконайте такі дії:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Відкрийте RPI Imager.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.moroz.cc/post/assembling-a-pikvm-v2-device-for-remote-kvm-over-ip-control-of-a-computer-or-server/rpi-img0.png&#34;
	width=&#34;1166&#34;
	height=&#34;520&#34;
	srcset=&#34;https://blog.moroz.cc/post/assembling-a-pikvm-v2-device-for-remote-kvm-over-ip-control-of-a-computer-or-server/rpi-img0_hu4100138426476572264.png 480w, https://blog.moroz.cc/post/assembling-a-pikvm-v2-device-for-remote-kvm-over-ip-control-of-a-computer-or-server/rpi-img0_hu13042572613264874815.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;Програмне забезпечення RPI Imager.&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;224&#34;
		data-flex-basis=&#34;538px&#34;
	
&gt;&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;Натисніть &amp;ldquo;Choose device&amp;rdquo; та виберіть модель вашої плати Raspberry Pi. В моєму випадку слід обрати &amp;ldquo;Raspberry Pi 4&amp;rdquo;.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.moroz.cc/post/assembling-a-pikvm-v2-device-for-remote-kvm-over-ip-control-of-a-computer-or-server/rpi-img1.png&#34;
	width=&#34;1161&#34;
	height=&#34;581&#34;
	srcset=&#34;https://blog.moroz.cc/post/assembling-a-pikvm-v2-device-for-remote-kvm-over-ip-control-of-a-computer-or-server/rpi-img1_hu17840736908026554909.png 480w, https://blog.moroz.cc/post/assembling-a-pikvm-v2-device-for-remote-kvm-over-ip-control-of-a-computer-or-server/rpi-img1_hu7671345283205519515.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;Вибір моделі плати.&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;199&#34;
		data-flex-basis=&#34;479px&#34;
	
&gt;&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;Натисніть &amp;ldquo;Choose OS&amp;rdquo;, прокрутіть до самого низу та виберіть опцію &amp;ldquo;Use custom image&amp;rdquo;. Потім у файловому менеджері виберіть завантажений раніше образ PiKVM.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.moroz.cc/post/assembling-a-pikvm-v2-device-for-remote-kvm-over-ip-control-of-a-computer-or-server/rpi-img2.png&#34;
	width=&#34;1161&#34;
	height=&#34;577&#34;
	srcset=&#34;https://blog.moroz.cc/post/assembling-a-pikvm-v2-device-for-remote-kvm-over-ip-control-of-a-computer-or-server/rpi-img2_hu7402771228493788739.png 480w, https://blog.moroz.cc/post/assembling-a-pikvm-v2-device-for-remote-kvm-over-ip-control-of-a-computer-or-server/rpi-img2_hu6518360933605357921.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;Вибір кастомного образу.&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;201&#34;
		data-flex-basis=&#34;482px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.moroz.cc/post/assembling-a-pikvm-v2-device-for-remote-kvm-over-ip-control-of-a-computer-or-server/rpi-img3.png&#34;
	width=&#34;618&#34;
	height=&#34;403&#34;
	srcset=&#34;https://blog.moroz.cc/post/assembling-a-pikvm-v2-device-for-remote-kvm-over-ip-control-of-a-computer-or-server/rpi-img3_hu669543994961920198.png 480w, https://blog.moroz.cc/post/assembling-a-pikvm-v2-device-for-remote-kvm-over-ip-control-of-a-computer-or-server/rpi-img3_hu7619456056555602041.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;Вибір файла образу.&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;153&#34;
		data-flex-basis=&#34;368px&#34;
	
&gt;&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;Натисніть &amp;ldquo;Choose storage&amp;rdquo; та виберіть картку пам&amp;rsquo;яті. Будьте обережні, та обирайте правильний пристрій, тому що RPI Imager відформатує вибраний пристрій.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.moroz.cc/post/assembling-a-pikvm-v2-device-for-remote-kvm-over-ip-control-of-a-computer-or-server/rpi-img4.png&#34;
	width=&#34;1164&#34;
	height=&#34;579&#34;
	srcset=&#34;https://blog.moroz.cc/post/assembling-a-pikvm-v2-device-for-remote-kvm-over-ip-control-of-a-computer-or-server/rpi-img4_hu5929997612728527642.png 480w, https://blog.moroz.cc/post/assembling-a-pikvm-v2-device-for-remote-kvm-over-ip-control-of-a-computer-or-server/rpi-img4_hu2443087288622995189.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;Вибір дискового пристрою.&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;201&#34;
		data-flex-basis=&#34;482px&#34;
	
&gt;&lt;/p&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;Переконайтеся, що всі поля заповнено правильно та натисніть «Далі».&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.moroz.cc/post/assembling-a-pikvm-v2-device-for-remote-kvm-over-ip-control-of-a-computer-or-server/rpi-img5.png&#34;
	width=&#34;1159&#34;
	height=&#34;574&#34;
	srcset=&#34;https://blog.moroz.cc/post/assembling-a-pikvm-v2-device-for-remote-kvm-over-ip-control-of-a-computer-or-server/rpi-img5_hu11725796118393500652.png 480w, https://blog.moroz.cc/post/assembling-a-pikvm-v2-device-for-remote-kvm-over-ip-control-of-a-computer-or-server/rpi-img5_hu979935376441915946.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;Підготовка до запису.&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;201&#34;
		data-flex-basis=&#34;484px&#34;
	
&gt;&lt;/p&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;Далі ви побачите модальне діалогове вікно із запитом, чи бажаєте ви налаштувати деякі параметри, натисніть «НІ».&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.moroz.cc/post/assembling-a-pikvm-v2-device-for-remote-kvm-over-ip-control-of-a-computer-or-server/rpi-img6.png&#34;
	width=&#34;1160&#34;
	height=&#34;579&#34;
	srcset=&#34;https://blog.moroz.cc/post/assembling-a-pikvm-v2-device-for-remote-kvm-over-ip-control-of-a-computer-or-server/rpi-img6_hu652147043370088316.png 480w, https://blog.moroz.cc/post/assembling-a-pikvm-v2-device-for-remote-kvm-over-ip-control-of-a-computer-or-server/rpi-img6_hu3537579023227109840.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;Діалогове вікно.&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;200&#34;
		data-flex-basis=&#34;480px&#34;
	
&gt;&lt;/p&gt;
&lt;ol start=&#34;7&#34;&gt;
&lt;li&gt;Наостанок підтвердьте процес спалаху пристрою та зачекайте, доки RPI Imager завершить спалах і перевірку зображення.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.moroz.cc/post/assembling-a-pikvm-v2-device-for-remote-kvm-over-ip-control-of-a-computer-or-server/rpi-img7.png&#34;
	width=&#34;1160&#34;
	height=&#34;577&#34;
	srcset=&#34;https://blog.moroz.cc/post/assembling-a-pikvm-v2-device-for-remote-kvm-over-ip-control-of-a-computer-or-server/rpi-img7_hu10932491511144931484.png 480w, https://blog.moroz.cc/post/assembling-a-pikvm-v2-device-for-remote-kvm-over-ip-control-of-a-computer-or-server/rpi-img7_hu1567695107752966645.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;Підтвердження запису образу.&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;201&#34;
		data-flex-basis=&#34;482px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;налаштування-підключення-до-wi-fi-необовязково&#34;&gt;Налаштування підключення до Wi-Fi (необов&amp;rsquo;язково)&lt;/h3&gt;
&lt;p&gt;Як я вже зазначав раніше, завжди краще використовувати кабельне інтернет з’єднання Ethernet RJ-45, оскільки воно надійніше та забезпечує кращу продуктивність відеопотоку та меншу затримку. Однак, оскільки я хочу, щоб пристрій був портативним, і я міг взяти його з собою та підключити до іншого комп&amp;rsquo;ютера, де, можливо, не буде можливості кабельного з’єднання. Для цього я встановлюю облікові дані Wi-Fi мережі точки доступу свого телефону на Android, який я завжди маю при собі, тому, коли плата Raspberry Pi завантажується без підключеного кабелю Ethernet, вона використовуватиме свій вбудований адаптер Wi-Fi і підключитися до мого телефону Android.&lt;/p&gt;
&lt;p&gt;Щоб налаштувати Wi-Fi, виконайте такі дії:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Підключіть SD-карту до комп&amp;rsquo;ютера.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Ви побачите, що SD-карта має більше одного розділу, вам потрібно змонтувати перший розділ, який називається &amp;ldquo;PIBOOT&amp;rdquo;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.moroz.cc/post/assembling-a-pikvm-v2-device-for-remote-kvm-over-ip-control-of-a-computer-or-server/rpi-wifi0.png&#34;
	width=&#34;209&#34;
	height=&#34;163&#34;
	srcset=&#34;https://blog.moroz.cc/post/assembling-a-pikvm-v2-device-for-remote-kvm-over-ip-control-of-a-computer-or-server/rpi-wifi0_hu14393555490339550946.png 480w, https://blog.moroz.cc/post/assembling-a-pikvm-v2-device-for-remote-kvm-over-ip-control-of-a-computer-or-server/rpi-wifi0_hu5075913822542401670.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;Розділи на картці пам&amp;rsquo;яті.&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;128&#34;
		data-flex-basis=&#34;307px&#34;
	
&gt;&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;
&lt;p&gt;Знайдіть файл &lt;code&gt;pikvm.txt&lt;/code&gt; в кореневій папці розділу &amp;ldquo;PIBOOT&amp;rdquo;. Якщо файла не існує - створіть його вручну, якщо файл вже існує, не видаляйте з нього жодних конфігурацій, вам потрібно додати 2 параметри внизу файлу.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Додайте 2 параметри в кінець файлу. Замініть облікові дані у прикладі на облікові дані вашої мережі Wi-Fi.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;WIFI_ESSID&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;my_wifi_network&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;WIFI_PASSWD&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;the_most_secure_password_ever&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;Збережіть файл. Потім безпечно відключіть розділ і вийміть SD-карту. Встановіть SD-карту на плату.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;перше-завантаження&#34;&gt;Перше завантаження&lt;/h3&gt;
&lt;p&gt;Це важливий крок, оскільки під час першого завантаження PiKVM OS ініціалізує необхідні налаштування та генерує унікальні SSH-ключі та сертифікати безпеки.&lt;/p&gt;
&lt;p&gt;Для процедури першого завантаження виконайте такі кроки:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Встановіть SD-карту з прошитою ОС PiKVM на плату Raspberry Pi.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Підключіть плату Raspbery Pi до роутера за допомогою кабелю Ethernet RJ-45. Якщо у вас немає можливості використовувати Ethernet під час першого завантаження, ви можете налаштувати облікові дані Wi-Fi (як показано в попередньому кроці), але перед завантаженням переконайтеся, що мережа Wi-Fi доступна.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Завантажте плату Raspberry Pi. Для цього підключіть джерело живлення 5В 3А до порту USB-C на платі.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.moroz.cc/post/assembling-a-pikvm-v2-device-for-remote-kvm-over-ip-control-of-a-computer-or-server/img/IMG_9.jpg&#34;
	width=&#34;2652&#34;
	height=&#34;1997&#34;
	srcset=&#34;https://blog.moroz.cc/post/assembling-a-pikvm-v2-device-for-remote-kvm-over-ip-control-of-a-computer-or-server/img/IMG_9_hu11502581757241179101.jpg 480w, https://blog.moroz.cc/post/assembling-a-pikvm-v2-device-for-remote-kvm-over-ip-control-of-a-computer-or-server/img/IMG_9_hu16240494004164759524.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;Процедура першого завантаження мого PiKVM пристрою.&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;132&#34;
		data-flex-basis=&#34;318px&#34;
	
&gt;&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;Зачекайте деякий час, поки ОС PiKVM завершить першу ініціалізацію. Цей процес може тривати до 10 хвилин.&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;🔴 &lt;strong&gt;ВАЖЛИВО:&lt;/strong&gt; не від’єднуйте кабель живлення від плати Raspberry Pi, доки не завершиться перша ініціалізація завантаження.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;Після завершення процесу першого завантаження пристрій PiKVM підключиться до мережі та отримає локальну IP-адресу в локальній мережі вашого маршрутизатора. Щоб визначити, яку IP-адресу отримав PiKVM, перейдіть на сторінку налаштувань маршрутизатора та знайдіть підключені пристрої.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;У моєму випадку плата отримала IP-адресу &lt;code&gt;192.168.0.222&lt;/code&gt;, тому я буду використовувати її в усіх наступних прикладах. У вашому випадку IP-адреса буде іншою.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.moroz.cc/post/assembling-a-pikvm-v2-device-for-remote-kvm-over-ip-control-of-a-computer-or-server/router.jpg&#34;
	width=&#34;1056&#34;
	height=&#34;955&#34;
	srcset=&#34;https://blog.moroz.cc/post/assembling-a-pikvm-v2-device-for-remote-kvm-over-ip-control-of-a-computer-or-server/router_hu5362032232056219576.jpg 480w, https://blog.moroz.cc/post/assembling-a-pikvm-v2-device-for-remote-kvm-over-ip-control-of-a-computer-or-server/router_hu4328767219862226543.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;Пристрій PiKVM що підключено до локальної мережі роутера.&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;110&#34;
		data-flex-basis=&#34;265px&#34;
	
&gt;&lt;/p&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;
&lt;p&gt;Далі вам потрібен комп’ютер або смартфон, який під’єднаний до тієї ж локальної мережі, що й пристрій PiKVM. Відкрийте веб-браузер і перейдіть до URL-адреси IP-адреси &lt;code&gt;https://192.168.0.222&lt;/code&gt;. Облікові дані за замовчуванням: логін &lt;code&gt;admin&lt;/code&gt; з паролем &lt;code&gt;admin&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Змініть стандартні паролі, щоб захистити свій пристрій. Детальний опис того, як це зробити, є в &lt;a class=&#34;link&#34; href=&#34;https://docs.pikvm.org/v2/#first-launch-and-usage&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;докуменації PiKVM&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.moroz.cc/post/assembling-a-pikvm-v2-device-for-remote-kvm-over-ip-control-of-a-computer-or-server/pw_change.png&#34;
	width=&#34;752&#34;
	height=&#34;547&#34;
	srcset=&#34;https://blog.moroz.cc/post/assembling-a-pikvm-v2-device-for-remote-kvm-over-ip-control-of-a-computer-or-server/pw_change_hu4692008650783861304.png 480w, https://blog.moroz.cc/post/assembling-a-pikvm-v2-device-for-remote-kvm-over-ip-control-of-a-computer-or-server/pw_change_hu17787389886763927875.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;Процедура зміни стандартних паролів.&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;137&#34;
		data-flex-basis=&#34;329px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;оновлення-програмного-забезпечення-pikvm-os&#34;&gt;Оновлення програмного забезпечення PiKVM OS&lt;/h3&gt;
&lt;p&gt;PiKVM OS — це операційна система з відкритим кодом на базі Arch Linux. Важливо регулярно оновлювати ОС PiKVM, щоб отримувати оновлення безпеки та нові функції. Як і оновлення будь якої системи, основаної на базі ядра Linux, процедура також виконується через термінал. Ви можете використовувати оболонку ssh або термінал вбудований в веб-інтерфейс PiKVM.&lt;/p&gt;
&lt;p&gt;Щоб оновити ОС, виконайте такі дії:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Відкрийте термінал у веб-інтерфейсі PiKVM. В якості альтернативи можна використовувати ssh.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Отримайте root-доступ, ввівши команду &lt;code&gt;su -&lt;/code&gt; і пароль від користувачва root.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Виконайте команду &lt;code&gt;pikvm-update&lt;/code&gt; і дочекайтеся завершення процесу. Будь ласка, переконайтеся, що ваш пристрій PiKVM не буде від&amp;rsquo;єднано від живлення та підключення до мережі інтернет під час процесу оновлення.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;налаштування-tailscale-vpn-необовязково&#34;&gt;Налаштування Tailscale VPN (необов’язково)&lt;/h3&gt;
&lt;p&gt;Можуть виникнути ситуації, коли я не можу отримати доступ до однієї локальної мережі з платою PiKVM, наприклад, коли я підключив PiKVM до домашнього сервера, і я фізично не вдома, і мені потрібен віддалений доступ до мого сервера.&lt;/p&gt;
&lt;p&gt;Крім того, враховуючи критерій щоб PiKVM був максимально портативним, я також хочу мати можливість позичити свій пристрій PiKVM комусь, щоб ця особа могла взяти його та підключити до свого ПК та локальної мережі, а я в свою чергу міг підключитися до цього ПК віддалено, та, наприклад, зміг допогти встановити операційну систему.&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://tailscale.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Tailscale VPN&lt;/a&gt; — це безкоштовний інструмент (для особистого користування), який можна використовувати як рішення для вище описаних випадків. Він дозволяє отримати доступ до PiKVM через мережу інтернет. Щоб налаштувати його, виконайте такі дії:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Відкрийте термінал у веб-інтерфейсі PiKVM. В якості альтернативи можна використовувати ssh.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Встановіть службу tailscale, ввівши цю послідовність команд в терміналі:&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;su -
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;rw
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;pacman -S tailscale-pikvm
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;systemctl &lt;span class=&#34;nb&#34;&gt;enable&lt;/span&gt; --now tailscaled
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;tailscale up
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;
&lt;p&gt;Термінал покаже посилання, яке потрібно скопіювати та перейти у веб-браузері. Після переходу за посиланням увійдіть або зареєструйтеся в Tailscale VPN, тоді ваш пристрій PiKVM буде долучено до цього облікового запису.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Встановіть клієнт Tailscale у систему, яку ви хочете використовувати (не на комп’ютер, яким хочете керувати через PiKVM), і підключіть його до VPN. Для цього дотримуйтесь інструкцій &lt;a class=&#34;link&#34; href=&#34;https://tailscale.com/download&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;тут&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Після налаштування клієнта у вашій системі відвідайте &lt;a class=&#34;link&#34; href=&#34;https://login.tailscale.com/admin/machines&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;сторінку адміністратора Tailscale&lt;/a&gt;. Якщо ви все зробили правильно, ви повинні побачити свій пристрій PiKVM і систему, що використовується для віддаленого підключення до PiKVM.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.moroz.cc/post/assembling-a-pikvm-v2-device-for-remote-kvm-over-ip-control-of-a-computer-or-server/tailscale_admin1.jpg&#34;
	width=&#34;1163&#34;
	height=&#34;516&#34;
	srcset=&#34;https://blog.moroz.cc/post/assembling-a-pikvm-v2-device-for-remote-kvm-over-ip-control-of-a-computer-or-server/tailscale_admin1_hu11672088242962744173.jpg 480w, https://blog.moroz.cc/post/assembling-a-pikvm-v2-device-for-remote-kvm-over-ip-control-of-a-computer-or-server/tailscale_admin1_hu12697132127269670673.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;Інформаційна панель адміністратора TailScale, на якій показано підключені пристрої.&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;225&#34;
		data-flex-basis=&#34;540px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;На знімку екрана вище я виділив приклад IP-адреси, яку слід використовувати в браузері для віддаленого підключення до PiKVM.&lt;/p&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;Переконайтеся, що ви вимкнули термін дії ключа для пристрою PiKVM. Щоб зробити це, натисніть значок «три крапки» праворуч від пристрою PiKVM у списку та виберіть опцію «Вимкнути термін дії ключа».&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Після завершення налаштування під час кожного завантаження пристрою PiKVM він автоматично підключатиметься до мережі VPN, тому, якщо мені потрібен віддалений доступ до нього з будь-якого місця, я можу просто підключити свій ноутбук чи телефон, що маю з собою, до тієї ж мережі VPN та керувати своїм пристроєм PiKVM.&lt;/p&gt;
&lt;h2 id=&#34;інструкція-з-використання-пристрою-pikvm-для-керування-пк--ноутбуком--сервером&#34;&gt;Інструкція з використання пристрою PiKVM для керування ПК / ноутбуком / сервером&lt;/h2&gt;
&lt;p&gt;Це інструкція стосується використання пристрою PiKVM як портативного. Для підключення вам необхідно мати: пристрій &lt;strong&gt;PiKVM&lt;/strong&gt;, &lt;strong&gt;машину&lt;/strong&gt;, якою ви хочете керувати, спеціальний кабель живлення та адаптер, кабель Ethernet RJ-45, кабель HDMI.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Візьміть кабель &lt;strong&gt;Ethernet RJ-45&lt;/strong&gt; та підключіть його до пристрою &lt;strong&gt;PiKVM&lt;/strong&gt; та до вашого &lt;strong&gt;роутера&lt;/strong&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.moroz.cc/post/assembling-a-pikvm-v2-device-for-remote-kvm-over-ip-control-of-a-computer-or-server/img/IMG_8.jpg&#34;
	width=&#34;1743&#34;
	height=&#34;1552&#34;
	srcset=&#34;https://blog.moroz.cc/post/assembling-a-pikvm-v2-device-for-remote-kvm-over-ip-control-of-a-computer-or-server/img/IMG_8_hu12927432579760435346.jpg 480w, https://blog.moroz.cc/post/assembling-a-pikvm-v2-device-for-remote-kvm-over-ip-control-of-a-computer-or-server/img/IMG_8_hu11250767973265040350.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;Ethernet RJ-45 що підключено до PiKVM.&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;112&#34;
		data-flex-basis=&#34;269px&#34;
	
&gt;
&lt;img src=&#34;https://blog.moroz.cc/post/assembling-a-pikvm-v2-device-for-remote-kvm-over-ip-control-of-a-computer-or-server/img/IMG_7.jpg&#34;
	width=&#34;2383&#34;
	height=&#34;1541&#34;
	srcset=&#34;https://blog.moroz.cc/post/assembling-a-pikvm-v2-device-for-remote-kvm-over-ip-control-of-a-computer-or-server/img/IMG_7_hu13073030356745473270.jpg 480w, https://blog.moroz.cc/post/assembling-a-pikvm-v2-device-for-remote-kvm-over-ip-control-of-a-computer-or-server/img/IMG_7_hu8277882780642044188.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;Ethernet RJ-45 що підключено до роутера.&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;154&#34;
		data-flex-basis=&#34;371px&#34;
	
&gt;
&lt;img src=&#34;https://blog.moroz.cc/post/assembling-a-pikvm-v2-device-for-remote-kvm-over-ip-control-of-a-computer-or-server/img/IMG_6.jpg&#34;
	width=&#34;2188&#34;
	height=&#34;1318&#34;
	srcset=&#34;https://blog.moroz.cc/post/assembling-a-pikvm-v2-device-for-remote-kvm-over-ip-control-of-a-computer-or-server/img/IMG_6_hu4658498443439687423.jpg 480w, https://blog.moroz.cc/post/assembling-a-pikvm-v2-device-for-remote-kvm-over-ip-control-of-a-computer-or-server/img/IMG_6_hu7254739209202189401.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;Мережеве з&amp;rsquo;єданння між роутером та PiKVM.&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;166&#34;
		data-flex-basis=&#34;398px&#34;
	
&gt;&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;Візьміть кабель &lt;strong&gt;HDMI&lt;/strong&gt; та підключіть його до пристрою &lt;strong&gt;PiKVM&lt;/strong&gt; та до &lt;strong&gt;машини&lt;/strong&gt;, якою ви хочете керувати.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.moroz.cc/post/assembling-a-pikvm-v2-device-for-remote-kvm-over-ip-control-of-a-computer-or-server/img/IMG_5.jpg&#34;
	width=&#34;1611&#34;
	height=&#34;1362&#34;
	srcset=&#34;https://blog.moroz.cc/post/assembling-a-pikvm-v2-device-for-remote-kvm-over-ip-control-of-a-computer-or-server/img/IMG_5_hu5717447596864417266.jpg 480w, https://blog.moroz.cc/post/assembling-a-pikvm-v2-device-for-remote-kvm-over-ip-control-of-a-computer-or-server/img/IMG_5_hu10337834441483334350.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;HDMI кабель що підключено до PiKVM.&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;118&#34;
		data-flex-basis=&#34;283px&#34;
	
&gt;
&lt;img src=&#34;https://blog.moroz.cc/post/assembling-a-pikvm-v2-device-for-remote-kvm-over-ip-control-of-a-computer-or-server/img/IMG_4.jpg&#34;
	width=&#34;2110&#34;
	height=&#34;1357&#34;
	srcset=&#34;https://blog.moroz.cc/post/assembling-a-pikvm-v2-device-for-remote-kvm-over-ip-control-of-a-computer-or-server/img/IMG_4_hu7429229186137975492.jpg 480w, https://blog.moroz.cc/post/assembling-a-pikvm-v2-device-for-remote-kvm-over-ip-control-of-a-computer-or-server/img/IMG_4_hu11342425139819630198.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;HDMIабель що підключено до ноутбука (буде розпізнаватися як монітор у системі).&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;155&#34;
		data-flex-basis=&#34;373px&#34;
	
&gt;
&lt;img src=&#34;https://blog.moroz.cc/post/assembling-a-pikvm-v2-device-for-remote-kvm-over-ip-control-of-a-computer-or-server/img/IMG_3.jpg&#34;
	width=&#34;1665&#34;
	height=&#34;2477&#34;
	srcset=&#34;https://blog.moroz.cc/post/assembling-a-pikvm-v2-device-for-remote-kvm-over-ip-control-of-a-computer-or-server/img/IMG_3_hu9081464994234904598.jpg 480w, https://blog.moroz.cc/post/assembling-a-pikvm-v2-device-for-remote-kvm-over-ip-control-of-a-computer-or-server/img/IMG_3_hu14785043661241705487.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;HDMI з&amp;rsquo;єданння між PiKVM ноутбуком.&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;67&#34;
		data-flex-basis=&#34;161px&#34;
	
&gt;&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;Візьміть спеціальний кабель живлення та підключіть:
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;USB-C&lt;/strong&gt; роз&amp;rsquo;єм до пристрою &lt;strong&gt;PiKVM&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;USB-A&lt;/strong&gt; роз&amp;rsquo;єм що позначено &lt;em&gt;&amp;ldquo;PC/Laptop (комп&amp;rsquo;ютер)&amp;rdquo;&lt;/em&gt; до &lt;strong&gt;машини&lt;/strong&gt;, якою ви хочете керувати.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;USB-A&lt;/strong&gt; роз&amp;rsquo;єм що позначено &lt;em&gt;&amp;ldquo;Power (живлення)&amp;rdquo;&lt;/em&gt; до &lt;strong&gt;адаптера живлення&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.moroz.cc/post/assembling-a-pikvm-v2-device-for-remote-kvm-over-ip-control-of-a-computer-or-server/img/IMG_2.jpg&#34;
	width=&#34;1557&#34;
	height=&#34;2036&#34;
	srcset=&#34;https://blog.moroz.cc/post/assembling-a-pikvm-v2-device-for-remote-kvm-over-ip-control-of-a-computer-or-server/img/IMG_2_hu18130387726807736717.jpg 480w, https://blog.moroz.cc/post/assembling-a-pikvm-v2-device-for-remote-kvm-over-ip-control-of-a-computer-or-server/img/IMG_2_hu7633090793140941502.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;Підключення USB-C роз&amp;rsquo;єму до PiKVM пристрою.&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;76&#34;
		data-flex-basis=&#34;183px&#34;
	
&gt;
&lt;img src=&#34;https://blog.moroz.cc/post/assembling-a-pikvm-v2-device-for-remote-kvm-over-ip-control-of-a-computer-or-server/img/IMG_1.jpg&#34;
	width=&#34;1916&#34;
	height=&#34;1203&#34;
	srcset=&#34;https://blog.moroz.cc/post/assembling-a-pikvm-v2-device-for-remote-kvm-over-ip-control-of-a-computer-or-server/img/IMG_1_hu6957170396218401372.jpg 480w, https://blog.moroz.cc/post/assembling-a-pikvm-v2-device-for-remote-kvm-over-ip-control-of-a-computer-or-server/img/IMG_1_hu10373957517381546310.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;Підключення USB-A роз&amp;rsquo;єму для передачі даних до ноутбука (буде розпізнаватися як миша/клавіатура в системі.).&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;159&#34;
		data-flex-basis=&#34;382px&#34;
	
&gt;
&lt;img src=&#34;https://blog.moroz.cc/post/assembling-a-pikvm-v2-device-for-remote-kvm-over-ip-control-of-a-computer-or-server/img/IMG.jpg&#34;
	width=&#34;1842&#34;
	height=&#34;2150&#34;
	srcset=&#34;https://blog.moroz.cc/post/assembling-a-pikvm-v2-device-for-remote-kvm-over-ip-control-of-a-computer-or-server/img/IMG_hu9175989119721185715.jpg 480w, https://blog.moroz.cc/post/assembling-a-pikvm-v2-device-for-remote-kvm-over-ip-control-of-a-computer-or-server/img/IMG_hu9723996004203649620.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;Підключення USB-A роз&amp;rsquo;єму до адаптера живлення 5V 3A.&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;85&#34;
		data-flex-basis=&#34;205px&#34;
	
&gt;&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;
&lt;p&gt;Підключіть &lt;strong&gt;адаптер живлення&lt;/strong&gt; до електричної розетки. Пристрій &lt;strong&gt;PiKVM&lt;/strong&gt; має завантажитися та підключитися до мережі.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Запустіть &lt;strong&gt;машину&lt;/strong&gt;, якою ви хочете керувати.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Після цього ви зможете підключитися до пристрою &lt;strong&gt;PiKVM&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.moroz.cc/post/assembling-a-pikvm-v2-device-for-remote-kvm-over-ip-control-of-a-computer-or-server/pikvm-web.png&#34;
	width=&#34;1892&#34;
	height=&#34;1024&#34;
	srcset=&#34;https://blog.moroz.cc/post/assembling-a-pikvm-v2-device-for-remote-kvm-over-ip-control-of-a-computer-or-server/pikvm-web_hu9688570345688691484.png 480w, https://blog.moroz.cc/post/assembling-a-pikvm-v2-device-for-remote-kvm-over-ip-control-of-a-computer-or-server/pikvm-web_hu12362967959713237362.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;Приклад KVM сесії віддаленого керування ноутбуком через веб-інтерфейс PiKVM.&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;184&#34;
		data-flex-basis=&#34;443px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;висновки&#34;&gt;Висновки&lt;/h2&gt;
&lt;p&gt;В результаті цього проекту було зібрано портативний пристрій KVM через IP, який має весь необхідний для моїх потреб функціонал:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Пристрій може використовувати як Ethernet, так і Wi-Fi з&amp;rsquo;єднання.&lt;/li&gt;
&lt;li&gt;Пристроєм можна повністю керувати віддалено за допомогою VPN.&lt;/li&gt;
&lt;li&gt;Пристрій зібрано в спеціальному унікальному корпусі ручної роботи, що використовує активне охолодження для запобігання перегріванню пристрою, тому його можна безпечно використовувати 24/7.&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>Прокидання відеокарти PCI до Windows KVM на Arch Linux</title>
        <link>https://blog.moroz.cc/uk/post/%D0%BF%D1%80%D0%BE%D0%BA%D0%B8%D0%B4%D0%B0%D0%BD%D0%BD%D1%8F-%D0%B2%D1%96%D0%B4%D0%B5%D0%BE%D0%BA%D0%B0%D1%80%D1%82%D0%B8-pci-%D0%B4%D0%BE-windows-kvm-%D0%BD%D0%B0-arch-linux/</link>
        <pubDate>Mon, 18 Mar 2024 00:00:00 +0000</pubDate>
        
        <guid>https://blog.moroz.cc/uk/post/%D0%BF%D1%80%D0%BE%D0%BA%D0%B8%D0%B4%D0%B0%D0%BD%D0%BD%D1%8F-%D0%B2%D1%96%D0%B4%D0%B5%D0%BE%D0%BA%D0%B0%D1%80%D1%82%D0%B8-pci-%D0%B4%D0%BE-windows-kvm-%D0%BD%D0%B0-arch-linux/</guid>
        <description>&lt;img src="https://blog.moroz.cc/post/gpu-pci-passthrough-to-windows-kvm-on-arch-linux/header.webp" alt="Featured image of post Прокидання відеокарти PCI до Windows KVM на Arch Linux" /&gt;&lt;h2 id=&#34;вступ&#34;&gt;Вступ&lt;/h2&gt;
&lt;p&gt;Прокидання GPU в KVM відноситься до процесу безпосереднього призначення фізичного GPU (графічного пристрою) віртуальній машині, що працює на гіпервізорі KVM. Це дозволяє віртуальній машині мати виключний доступ до GPU, обійшовши практично віртуалізаційний шар гіпервізора.&lt;/p&gt;
&lt;p&gt;Для багатьох це може звучати складно, але з Linux та KVM це насправді легко, і налаштування включає наступні 5 кроків:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Перевірка GPU&lt;/strong&gt;. Перший крок - переконатися, що GPU, який ви хочете передати, сумісний з вашим обладнанням і підтримує необхідні функції для прохідного доступу. Це часто потребує підтримки VT-d (віртуалізаційна технологія Intel для прямого введення/виведення) або AMD-Vi (AMD віртуалізація I/O) на процесорі, а також IOMMU (одиниця управління пам&amp;rsquo;яттю введення/виведення) на материнській платі.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Налаштування хоста&lt;/strong&gt;. Вам потрібно налаштувати систему хоста для активації IOMMU, VT-d або AMD-Vi в налаштуваннях BIOS/UEFI, а також завантажити необхідні модулі ядра та драйвери.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Ізоляція GPU&lt;/strong&gt;. GPU, призначений для прохідного доступу, потрібно ізолювати від операційної системи хоста таким чином, щоб його можна було виключно призначити для віртуальної машини. Це зазвичай робиться шляхом блокування завантаження драйвера GPU на хості.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Налаштування віртуальної машини&lt;/strong&gt;. У межах налаштування KVM ви налаштовуєте віртуальну машину для використання GPU, що прокидується. Це включає вказівку GPU як пристрій PCI для передачі до ВМ.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Встановлення драйверів&lt;/strong&gt;. Після передачі GPU віртуальній машині ви встановлюєте необхідні драйвери в гостьовій операційній системі так само, як і на фізичній машині.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;вимоги-до-обладнання&#34;&gt;Вимоги до обладнання&lt;/h2&gt;
&lt;p&gt;Важливо відзначити, що для такого типу налаштувань необхідно, щоб ваше обладнання відповідало вимогам.&lt;/p&gt;
&lt;h3 id=&#34;цп-процесор&#34;&gt;ЦП (процесор)&lt;/h3&gt;
&lt;p&gt;Ваш процесор повинен підтримувати розширення апаратної віртуалізації, такі як Intel VT-x (Intel Virtualization Technology) або AMD-V (AMD Virtualization). Крім того, для пропускання GPU вам знадобиться підтримка розширень Intel VT-d (Intel Virtualization Technology for Directed I/O) або AMD-Vi (AMD Virtualization I/O), які дозволяють прямий доступ до пристроїв вводу-виводу з віртуальних машин.&lt;/p&gt;
&lt;h3 id=&#34;материнська-плата&#34;&gt;Материнська плата&lt;/h3&gt;
&lt;p&gt;Ваша материнська плата повинна мати IOMMU (Input-Output Memory Management Unit), яка підтримує ізоляцію та пропускання пристроїв PCIe. Більшість сучасних материнських плат мають цю функцію, але вам слід перевірити специфікації вашої материнської плати, щоб переконатися в сумісності.&lt;/p&gt;
&lt;h3 id=&#34;gpu-графічний-процесор&#34;&gt;GPU (графічний процесор)&lt;/h3&gt;
&lt;p&gt;Ваш графічний процесор повинен підтримувати UEFI. Ідеальним вибором буде GPU, який підтримує необхідні функції для пропускання, такі як GPU серії AMD Radeon Pro або Nvidia Quadro, оскільки в GPU для споживачів можуть бути обмеження або вимагати обхідних шляхів.&lt;/p&gt;
&lt;h2 id=&#34;налаштування-пропускання-gpu&#34;&gt;Налаштування пропускання GPU&lt;/h2&gt;
&lt;h3 id=&#34;перегляньте-ваше-обладнання&#34;&gt;Перегляньте ваше обладнання&lt;/h3&gt;
&lt;p&gt;Першим кроком для налаштування є перегляд вашого обладнання. Якщо ви хочете досягти такого ж налаштування, як у моєму випадку, переконайтеся, що у вас є 2 відеокарти (або принаймні одна зовнішня відеокарта PCI).&lt;/p&gt;
&lt;p&gt;Специфікації мого обладнання:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Материнська плата&lt;/strong&gt;: &lt;a class=&#34;link&#34; href=&#34;https://www.msi.com/Motherboard/MPG-Z490-GAMING-EDGE-WIFI&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;MSI MPG z490 Gaming Edge WiFi&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ЦП&lt;/strong&gt;: &lt;a class=&#34;link&#34; href=&#34;https://ark.intel.com/content/www/us/en/ark/products/205904/intel-core-i9-10850k-processor-20m-cache-up-to-5-20-ghz.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Intel Core i9-10850K&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;GPU 1&lt;/strong&gt;: &lt;a class=&#34;link&#34; href=&#34;https://www.amd.com/en/products/graphics/amd-radeon-rx-6750-xt&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;AMD Radeon RX 6750XT&lt;/a&gt; (для &lt;strong&gt;HOST&lt;/strong&gt; Linux)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;GPU 2&lt;/strong&gt;: &lt;a class=&#34;link&#34; href=&#34;https://www.amd.com/en/products/graphics/amd-radeon-rx-6600&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;AMD Radeon RX 6600&lt;/a&gt; (для &lt;strong&gt;GUEST&lt;/strong&gt; Windows)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Монітори&lt;/strong&gt;: 2 x FullHD 1920x1080 @ 75 Гц&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.moroz.cc/post/gpu-pci-passthrough-to-windows-kvm-on-arch-linux/gpu_hardware.jpg&#34;
	width=&#34;3746&#34;
	height=&#34;2036&#34;
	srcset=&#34;https://blog.moroz.cc/post/gpu-pci-passthrough-to-windows-kvm-on-arch-linux/gpu_hardware_hu5316848306174236222.jpg 480w, https://blog.moroz.cc/post/gpu-pci-passthrough-to-windows-kvm-on-arch-linux/gpu_hardware_hu2324413773942828971.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;Обладнання PCIE - Робоча станція з двома відеокартами&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;183&#34;
		data-flex-basis=&#34;441px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;встановлення-та-налаштування-kvm&#34;&gt;Встановлення та налаштування KVM&lt;/h3&gt;
&lt;p&gt;Цей посібник написаний з припущенням, що у вас вже працює система Linux з встановленим та налаштованим KVM (libvirt) та програмним забезпеченням для керування вашими віртуальними машинами (virt-manager, virt-viewer).&lt;/p&gt;
&lt;p&gt;Якщо у вас ще не встановлено KVM, перегляньте мій інший посібник: &lt;a class=&#34;link&#34; href=&#34;http://blog.moroz.cc/post/how-to-install-kvm-on-arch-linux&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Як встановити KVM на Arch Linux&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&#34;зміна-налаштувань-bios-материнської-плати&#34;&gt;Зміна налаштувань BIOS материнської плати&lt;/h3&gt;
&lt;p&gt;Для того щоб KVM працював на вашій системі, технологія віртуалізації повинна бути включена. Вона може мати різні назви залежно від виробника материнської плати/процесора, але зазвичай це VT-D для Intel та AMD-Vi для AMD відповідно.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.moroz.cc/post/gpu-pci-passthrough-to-windows-kvm-on-arch-linux/bios_virtualization.png&#34;
	width=&#34;1920&#34;
	height=&#34;1092&#34;
	srcset=&#34;https://blog.moroz.cc/post/gpu-pci-passthrough-to-windows-kvm-on-arch-linux/bios_virtualization_hu14537860528276522273.png 480w, https://blog.moroz.cc/post/gpu-pci-passthrough-to-windows-kvm-on-arch-linux/bios_virtualization_hu14410412353474061933.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;Приклад налаштувань віртуалізації на материнській платі MSI Z490 і процесорі Intel&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;175&#34;
		data-flex-basis=&#34;421px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;Якщо у вас є налаштування BIOS з інтегрованою графікою в процесорі, вам також потрібно буде змінити пріоритет ініціалізації графіки. Це потрібно для того, щоб запобігти ініціалізації зовнішнього GPU при старті BIOS POST, і делегувати відеосигнал інтегрованій графіці. У моєму випадку цей крок не потрібний, оскільки у мене є 2 зовнішні PCI GPU.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.moroz.cc/post/gpu-pci-passthrough-to-windows-kvm-on-arch-linux/bios_gpu_init_priority.png&#34;
	width=&#34;1920&#34;
	height=&#34;1096&#34;
	srcset=&#34;https://blog.moroz.cc/post/gpu-pci-passthrough-to-windows-kvm-on-arch-linux/bios_gpu_init_priority_hu4801827362415809405.png 480w, https://blog.moroz.cc/post/gpu-pci-passthrough-to-windows-kvm-on-arch-linux/bios_gpu_init_priority_hu14994768946575286753.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;Приклад налаштувань ініціалізації GPU на материнській платі MSI Z490&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;175&#34;
		data-flex-basis=&#34;420px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;увімкнення-iommu&#34;&gt;Увімкнення IOMMU&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;IOMMU - це загальна назва для Intel VT-d та AMD-Vi.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Для включення IOMMU в системі Linux вам слід передати правильний параметр завантаження ядра. Додавання параметрів завантаження ядра може відрізнятися в залежності від того, який завантажувач ви використовуєте.&lt;/p&gt;
&lt;p&gt;Якщо ви використовуєте:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Процесор Intel&lt;/strong&gt; - додайте прапори: &lt;code&gt;intel_iommu=on iommu=pt&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Процесор AMD&lt;/strong&gt; - додайте прапори: &lt;code&gt;iommu=pt&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;У випадку процесорів AMD ядро визначає, чи має бути увімкнений IOMMU з BIOS, і &lt;code&gt;iommu=pt&lt;/code&gt; запобігає обробці пристроїв, які не можуть бути пропущені через IOMMU.&lt;/p&gt;
&lt;h4 id=&#34;варіант-1-grub&#34;&gt;Варіант 1: GRUB&lt;/h4&gt;
&lt;p&gt;Якщо ви використовуєте grub як свій завантажувач, ви можете змінити параметри ядра в файлі &lt;code&gt;/etc/default/grub&lt;/code&gt; та додати прапори до параметрів &lt;code&gt;GRUB_CMDLINE_LINUX&lt;/code&gt;, наприклад:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;GRUB_CMDLINE_LINUX&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;quiet splash intel_iommu=on iommu=pt&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;Потім збережіть файл і перегенеруйте конфігурацію вашого GRUB за допомогою команди:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo grub-mkconfig -o /boot/grub/grub.cfg&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&#34;опція-2-завантаження-через-systemd-boot&#34;&gt;Опція 2: Завантаження через systemd Boot&lt;/h4&gt;
&lt;p&gt;Якщо ви використовуєте завантажувач systemd boot, вам потрібно відредагувати файл вашого завантаження. У моєму випадку цей файл розташований за адресою &lt;code&gt;/boot/loader/entries/arch.conf&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Параметри ядра слід додати в кінець параметра &lt;code&gt;options&lt;/code&gt;, наприклад:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;options rw quiet splash &lt;span class=&#34;nv&#34;&gt;intel_iommu&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;on &lt;span class=&#34;nv&#34;&gt;iommu&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;pt
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;Після додавання правильних параметрів ядра до вашого завантажувача, перезавантажте комп&amp;rsquo;ютер.&lt;/p&gt;
&lt;h3 id=&#34;перевірка-групування-iommu&#34;&gt;Перевірка групування IOMMU&lt;/h3&gt;
&lt;p&gt;Група IOMMU (Input-Output Memory Management Unit) - це логічне об&amp;rsquo;єднання пристроїв, які контролюються тією ж самою IOMMU. Основна мета групи IOMMU полягає в тому, щоб сприяти ізоляції та управлінню пристроями в віртуалізованих середовищах, зокрема при використанні технологій пропускання GPU.&lt;/p&gt;
&lt;p&gt;Важливо, щоб у тій самій групі IOMMU були лише пристрої, пов&amp;rsquo;язані з GPU, який ви маєте намір пропустити через них. Оскільки, якщо ви маєте щось інше, воно також повинно бути передане в ВМ, інакше пропускання не працюватиме.&lt;/p&gt;
&lt;p&gt;Ви можете скористатися наступним скриптом, щоб перевірити ваші групи iommu:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#!/bin/bash
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;shopt&lt;/span&gt; -s nullglob
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; g in &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;find /sys/kernel/iommu_groups/* -maxdepth &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; -type d &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; sort -V&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;do&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nb&#34;&gt;echo&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;IOMMU Group &lt;/span&gt;&lt;span class=&#34;si&#34;&gt;${&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;g&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;##*/&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;:&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; d in &lt;span class=&#34;nv&#34;&gt;$g&lt;/span&gt;/devices/*&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;do&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nb&#34;&gt;echo&lt;/span&gt; -e &lt;span class=&#34;s2&#34;&gt;&amp;#34;\t&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;lspci -nns &lt;span class=&#34;si&#34;&gt;${&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;##*/&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;done&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;done&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;Вам потрібно зберегти вміст скрипта у файл (наприклад, &lt;code&gt;iommu.sh&lt;/code&gt;) і зробити цей файл виконуваним (&lt;code&gt;chmod +x iommu.sh&lt;/code&gt;), після чого ви можете просто запустити його за допомогою &lt;code&gt;./iommu.sh&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;У моєму випадку групи IOMMU такі:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;IOMMU Group 0:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	00:00.0 Host bridge &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;0600&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;: Intel Corporation Comet Lake-S 6c Host Bridge/DRAM Controller &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;8086:9b33&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;rev 05&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;IOMMU Group 1:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	00:01.0 PCI bridge &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;0604&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;: Intel Corporation 6th-10th Gen Core Processor PCIe Controller &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;x16&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;8086:1901&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;rev 05&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	01:00.0 PCI bridge &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;0604&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;: Advanced Micro Devices, Inc. &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;AMD/ATI&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; Navi &lt;span class=&#34;m&#34;&gt;10&lt;/span&gt; XL Upstream Port of PCI Express Switch &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;1002:1478&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;rev c0&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	02:00.0 PCI bridge &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;0604&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;: Advanced Micro Devices, Inc. &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;AMD/ATI&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; Navi &lt;span class=&#34;m&#34;&gt;10&lt;/span&gt; XL Downstream Port of PCI Express Switch &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;1002:1479&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	03:00.0 VGA compatible controller &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;0300&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;: Advanced Micro Devices, Inc. &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;AMD/ATI&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; Navi &lt;span class=&#34;m&#34;&gt;22&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;Radeon RX 6700/6700 XT/6750 XT / 6800M/6850M XT&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;1002:73df&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;rev c0&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	03:00.1 Audio device &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;0403&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;: Advanced Micro Devices, Inc. &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;AMD/ATI&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; Navi 21/23 HDMI/DP Audio Controller &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;1002:ab28&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;IOMMU Group 18:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	07:00.0 VGA compatible controller &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;0300&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;: Advanced Micro Devices, Inc. &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;AMD/ATI&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; Navi &lt;span class=&#34;m&#34;&gt;23&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;Radeon RX 6600/6600 XT/6600M&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;1002:73ff&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;rev c7&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;IOMMU Group 19:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	07:00.1 Audio device &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;0403&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;: Advanced Micro Devices, Inc. &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;AMD/ATI&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; Navi 21/23 HDMI/DP Audio Controller &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;1002:ab28&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;Переконайтеся, що GPU та пов&amp;rsquo;язані з ним пристрої не згруповані з іншими критичними системними пристроями (наприклад, контролерами USB, контролерами Ethernet), які ви не маєте наміру передавати у віртуальну машину. Важливо, щоб GPU був у власній ізольованій групі IOMMU для надійного пропускання.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;У цьому випадку &lt;strong&gt;AMD RX 6600 GPU&lt;/strong&gt;, який я хочу передати до ВМ, має 2 пристрої &lt;strong&gt;07:00.0&lt;/strong&gt; і &lt;strong&gt;07:00.1&lt;/strong&gt;, кожен у окремій групі IOMMU &lt;strong&gt;18&lt;/strong&gt; і &lt;strong&gt;19&lt;/strong&gt;, і жодні інші пристрої не знаходяться в групах &lt;strong&gt;18&lt;/strong&gt; і &lt;strong&gt;19&lt;/strong&gt;. Це означає, що я можу пропускати його без проблем.&lt;/p&gt;
&lt;p&gt;Якщо ми подивимося на пристрої для &lt;strong&gt;AMD RX 6750 XT&lt;/strong&gt;, які є &lt;strong&gt;03:00.0&lt;/strong&gt; і &lt;strong&gt;03:00.1&lt;/strong&gt; у групі IOMMU &lt;strong&gt;1&lt;/strong&gt;, також є деякі пристрої PCI-мосту, які в теорії не заважатимуть пропусканню цього GPU, поки ви також передасте ці PCI-мости до ВМ. Справжньою проблемою було б, якщо, наприклад, група IOMMU &lt;strong&gt;1&lt;/strong&gt; містила б інший PCI-пристрій (наприклад, мост USB або звукову карту).&lt;/p&gt;
&lt;p&gt;У випадку, якщо у вас більше пристроїв, ніж вам потрібно в групі IOMMU з GPU, ви можете спробувати:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Якщо ваша материнська плата має багато слотів PCI Express, спробуйте встановити GPU в різні слоти PCI Express і подивіться, чи допоможе це.&lt;/li&gt;
&lt;li&gt;У випадку, якщо ви не можете знайти оптимальну групу IOMMU без зайвих пристроїв, ви можете патчити свій ядро Linux з патчем &lt;strong&gt;ACS Override&lt;/strong&gt; (але це виходить за рамки цієї статті).&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;ізолюйте-ваш-gpu&#34;&gt;Ізолюйте ваш GPU&lt;/h3&gt;
&lt;p&gt;Ізоляція GPU - це процес забезпечення того, що GPU доступний виключно для використання конкретною віртуальною машиною, зазвичай шляхом прив&amp;rsquo;язки його до драйвера VFIO (Virtual Function I/O). Цей процес включає кілька кроків для запобігання використання GPU операційною системою хоста або іншими віртуальними машинами:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Відв&amp;rsquo;язка від драйвера хоста&lt;/strong&gt;. Спочатку GPU зазвичай прив&amp;rsquo;язаний до драйвера, який використовується операційною системою хоста для звичайних графічних операцій. Для ізоляції GPU цю прив&amp;rsquo;язку потрібно скасувати, щоб GPU міг бути вибраний драйвером VFIO. Цей крок фактично відокремлює GPU від операційної системи хоста.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Прив&amp;rsquo;язка до драйвера VFIO&lt;/strong&gt;. Після відв&amp;rsquo;язки від драйвера хоста GPU прив&amp;rsquo;язується до драйвера VFIO, що дозволяє його передавати до віртуальної машини. Драйвер VFIO надає необхідну функціональність для прямого призначення пристроїв (DDA) в віртуалізованих середовищах, забезпечуючи доступність GPU для віртуальної машини.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Ізоляція означає, що після того, як ви завантажите вашу хостову операційну систему Linux, ви не зможете використовувати ізольований GPU (який прив&amp;rsquo;язаний до драйвера &lt;code&gt;vfio&lt;/code&gt;), ви можете використовувати його лише для передачі в ВМ.&lt;/p&gt;
&lt;p&gt;Для ізоляції GPU вам потрібно знати ідентифікатори пристроїв вашої відеокарти та аудіовиходу PCI. Ви можете використовувати скрипт &lt;code&gt;iommu.sh&lt;/code&gt; з попереднього кроку, щоб отримати цю інформацію. У моєму випадку ідентифікатори пристроїв - &lt;code&gt;1002:73df&lt;/code&gt; і &lt;code&gt;1002:ab28&lt;/code&gt;.&lt;/p&gt;
&lt;h4 id=&#34;раннє-завантаження-vfio&#34;&gt;Раннє завантаження VFIO&lt;/h4&gt;
&lt;p&gt;Щоб завантажити vfio ранніше та прив&amp;rsquo;язати необхідний GPU до vfio, створіть конфігураційний файл за адресою &lt;code&gt;/etc/modprobe.d/vfio.conf&lt;/code&gt;, який у моєму випадку виглядає наступним чином:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;softdep amdgpu pre: vfio-pci
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;options vfio-pci &lt;span class=&#34;nv&#34;&gt;ids&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;1002:73ff,1002:ab28 &lt;span class=&#34;nv&#34;&gt;disable_vga&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt; kvm.ignore_msrs&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;Тут рядок &lt;code&gt;softdep amdgpu pre: vfio-pci&lt;/code&gt; дозволяє примусово завантажити драйвер &lt;code&gt;vfio-pci&lt;/code&gt; перед драйвером &lt;code&gt;amdgpu&lt;/code&gt;. Мені це потрібно через те, що у мене є 2 зовнішні PCI GPU від одного виробника, і це дозволяє прив&amp;rsquo;язати GPU RX 6600 до драйвера &lt;code&gt;vfio-pci&lt;/code&gt;, а потім прив&amp;rsquo;язати RX 6750 XT до драйвера &lt;code&gt;amdgpu&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;У вашому випадку, якщо у вас є GPU NVidia, то &lt;code&gt;vfio-pci&lt;/code&gt; повинен бути завантажений перед драйвером &lt;code&gt;nvidia&lt;/code&gt; (пропрітарним) або перед драйвером &lt;code&gt;nouveau&lt;/code&gt; (вільним).&lt;/p&gt;
&lt;h4 id=&#34;налаштування-initramfs&#34;&gt;Налаштування initramfs&lt;/h4&gt;
&lt;p&gt;У моєму випадку я використовую &lt;code&gt;mkinitcpio&lt;/code&gt; як збирач initramfs. Для налаштування mkinitcpio відредагуйте файл &lt;code&gt;/etc/mkinitcpio.conf&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Додайте необхідні модулі до масиву &lt;code&gt;MODULES&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;MODULES&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=(&lt;/span&gt;vfio_pci vfio vfio_iommu_type1&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;Потім переконайтеся, що у вас визначений хук &lt;code&gt;modconf&lt;/code&gt; у масиві &lt;code&gt;HOOKS&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;HOOKS&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=(&lt;/span&gt;... modconf ...&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;Збережіть файл, а потім виконайте команду для регенерації initramfs:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo mkinitcpio -P&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Після цього потрібно перезавантажити комп&amp;rsquo;ютер, щоб зміни вступили в силу.&lt;/p&gt;
&lt;h3 id=&#34;налаштування-нової-віртуальної-машини-та-установка-windows-1011&#34;&gt;Налаштування нової віртуальної машини та установка Windows 10/11&lt;/h3&gt;
&lt;p&gt;Тепер час налаштувати нову віртуальну машину та встановити нову операційну систему Windows. Я рекомендую налаштовувати та встановлювати Windows без будь-яких переданих PCI-пристроїв, і додати їх до віртуальної машини пізніше після завершення встановлення.&lt;/p&gt;
&lt;p&gt;Все налаштування легше виконувати за допомогою графічного додатка &lt;code&gt;virt-manager&lt;/code&gt;.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Відкрийте додаток &lt;code&gt;virt-manager&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Натисніть &amp;ldquo;Нова віртуальна машина&amp;rdquo;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Виберіть локальний носій для встановлення. Зазвичай це файл образу iso Windows 10/11, який можна завантажити з веб-сайту Microsoft.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.moroz.cc/post/gpu-pci-passthrough-to-windows-kvm-on-arch-linux/vm1.png&#34;
	width=&#34;493&#34;
	height=&#34;493&#34;
	srcset=&#34;https://blog.moroz.cc/post/gpu-pci-passthrough-to-windows-kvm-on-arch-linux/vm1_hu18073896031278788223.png 480w, https://blog.moroz.cc/post/gpu-pci-passthrough-to-windows-kvm-on-arch-linux/vm1_hu6602310145448245060.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;Virt Manager - Локальний образ для встановлення ОС&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;100&#34;
		data-flex-basis=&#34;240px&#34;
	
&gt;&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;Перейдіть до вашого файлу &lt;code&gt;iso&lt;/code&gt; Windows 10/11. Рекомендується розташувати ваш iso десь у вашій домашній теки користувача, щоб уникнути проблем з правами доступу до файлів. Також важливо переконатися, що операційна система ідентифікована як &amp;ldquo;Windows 10&amp;rdquo; або &amp;ldquo;Windows 11&amp;rdquo; у нижньому полі.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.moroz.cc/post/gpu-pci-passthrough-to-windows-kvm-on-arch-linux/vm2.png&#34;
	width=&#34;494&#34;
	height=&#34;491&#34;
	srcset=&#34;https://blog.moroz.cc/post/gpu-pci-passthrough-to-windows-kvm-on-arch-linux/vm2_hu11950223325433741524.png 480w, https://blog.moroz.cc/post/gpu-pci-passthrough-to-windows-kvm-on-arch-linux/vm2_hu6122348967997760476.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;Virt Manager - Шлях до ISO та тип операційної системи&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;100&#34;
		data-flex-basis=&#34;241px&#34;
	
&gt;&lt;/p&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;Виділіть CPU та пам&amp;rsquo;ять. Переконайтеся, що зарезервовано принаймні 2 ядра CPU та деяку кількість оперативної пам&amp;rsquo;яті для вашої системи хоста Linux, щоб вона могла керувати мережею та іншими процесами. У моєму випадку я виділив 2 ядра CPU та 8 Гб оперативної пам&amp;rsquo;яті для ВМ, ви можете виділити більше, якщо потрібно.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.moroz.cc/post/gpu-pci-passthrough-to-windows-kvm-on-arch-linux/vm3.png&#34;
	width=&#34;494&#34;
	height=&#34;492&#34;
	srcset=&#34;https://blog.moroz.cc/post/gpu-pci-passthrough-to-windows-kvm-on-arch-linux/vm3_hu10945930333721977693.png 480w, https://blog.moroz.cc/post/gpu-pci-passthrough-to-windows-kvm-on-arch-linux/vm3_hu9887751238817905722.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;Virt Manager - Виділення системних ресурсів&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;100&#34;
		data-flex-basis=&#34;240px&#34;
	
&gt;&lt;/p&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;Увімкніть зберігання для цієї віртуальної машини та створіть образ диску. Я рекомендую виділити принаймні 50 Гб для віртуальної машини Windows.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.moroz.cc/post/gpu-pci-passthrough-to-windows-kvm-on-arch-linux/vm4.png&#34;
	width=&#34;491&#34;
	height=&#34;490&#34;
	srcset=&#34;https://blog.moroz.cc/post/gpu-pci-passthrough-to-windows-kvm-on-arch-linux/vm4_hu7867447878356202190.png 480w, https://blog.moroz.cc/post/gpu-pci-passthrough-to-windows-kvm-on-arch-linux/vm4_hu10148646427734098499.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;Virt Manager - Виділення дискового простору&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;100&#34;
		data-flex-basis=&#34;240px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;Потім &lt;strong&gt;НЕ НАТИСКАЙТЕ FINISH&lt;/strong&gt;, і виконайте наступне:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Переконайтеся, що увімкнено &amp;ldquo;Customize Configuration before install&amp;rdquo;.&lt;/li&gt;
&lt;li&gt;Дайте вашій ВМ назву.&lt;/li&gt;
&lt;li&gt;У виборі мережі оберіть &amp;ldquo;Пристрій хоста [ваш ID пристрою] -&amp;gt; Source Mode -&amp;gt; Bridge або NAT&amp;rdquo;.&lt;/li&gt;
&lt;li&gt;Тепер ви можете натиснути &amp;ldquo;Finish&amp;rdquo;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.moroz.cc/post/gpu-pci-passthrough-to-windows-kvm-on-arch-linux/vm5.png&#34;
	width=&#34;492&#34;
	height=&#34;490&#34;
	srcset=&#34;https://blog.moroz.cc/post/gpu-pci-passthrough-to-windows-kvm-on-arch-linux/vm5_hu17891980543552084179.png 480w, https://blog.moroz.cc/post/gpu-pci-passthrough-to-windows-kvm-on-arch-linux/vm5_hu3597440930435823089.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;Virt Manager - Назва ВМ, віртуальний мережевий адаптер&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;100&#34;
		data-flex-basis=&#34;240px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Переконайтеся, що в «Огляді» вибрано чіпсет &lt;strong&gt;Q35&lt;/strong&gt; і мікропрограму &lt;strong&gt;UEFI&lt;/strong&gt;. GPU Passthrough не працюватиме в мікропрограмі BIOS, для цього потрібно використовувати &lt;strong&gt;UEFI&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.moroz.cc/post/gpu-pci-passthrough-to-windows-kvm-on-arch-linux/vm6.png&#34;
	width=&#34;1015&#34;
	height=&#34;802&#34;
	srcset=&#34;https://blog.moroz.cc/post/gpu-pci-passthrough-to-windows-kvm-on-arch-linux/vm6_hu12238543899330835909.png 480w, https://blog.moroz.cc/post/gpu-pci-passthrough-to-windows-kvm-on-arch-linux/vm6_hu3686758649475576161.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;Virt Manager - Конфігураціятипу та прошивки чіпсета (Q35 UEFI).&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;126&#34;
		data-flex-basis=&#34;303px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;Потім натисніть &amp;ldquo;Begin installation&amp;rdquo; та встановіть Windows, як зазвичай. Після встановлення системи перейдіть до наступного кроку.&lt;/p&gt;
&lt;h3 id=&#34;налаштування-певних-параметрів-вм&#34;&gt;Налаштування певних параметрів ВМ&lt;/h3&gt;
&lt;p&gt;Є необхідність додати деякі параметри, що дозволяють приховати той факт, що ви використовуєте віртуальну машину від програми встановлення драйверів GPU.&lt;/p&gt;
&lt;p&gt;Для редагування налаштувань ВМ переконайтеся, що ваша ВМ не запущена, і введіть цю команду в термінал:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo virsh edit win10&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;де ви повинні замінити &lt;code&gt;win10&lt;/code&gt; на ім&amp;rsquo;я вашої ВМ.&lt;/p&gt;
&lt;p&gt;Потім виконайте наступні зміни в файлі XML в редакторі:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Додайте &lt;code&gt;&amp;lt;vendor_id state=&#39;on&#39; value=&#39;randomid&#39;/&amp;gt;&lt;/code&gt; до розділу &lt;code&gt;&amp;lt;hyperv&amp;gt;&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Додайте &lt;code&gt;&amp;lt;kvm&amp;gt;&amp;lt;hidden state=&#39;on&#39;/&amp;gt;&amp;lt;/kvm&amp;gt;&lt;/code&gt; до розділу &lt;code&gt;&amp;lt;features&amp;gt;&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;В результаті структура повинна виглядати так:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;lt;features&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  ...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &amp;lt;hyperv&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    ...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &amp;lt;vendor_id &lt;span class=&#34;nv&#34;&gt;state&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;on&amp;#39;&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;randomid&amp;#39;&lt;/span&gt;/&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    ...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &amp;lt;/hyperv&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &amp;lt;kvm&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &amp;lt;hidden &lt;span class=&#34;nv&#34;&gt;state&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;on&amp;#39;&lt;/span&gt;/&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &amp;lt;/kvm&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  ...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;lt;/features&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;прокидання-gpu-до-вм&#34;&gt;Прокидання GPU до ВМ&lt;/h3&gt;
&lt;p&gt;У програмі &lt;code&gt;virt-manager&lt;/code&gt; відкрийте налаштування вашої ВМ та перейдіть до відповідних налаштувань, де потрібно додати 2 PCI-пристрої хоста, пов&amp;rsquo;язані з GPU, який ви маєте намір пропустити.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Натисніть &amp;ldquo;Додати пристрої PCI&amp;rdquo;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Натисніть &amp;ldquo;Додати обладнання&amp;rdquo;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Виберіть PCI-пристрій хоста&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Прокрутіть вниз, поки не знайдете GPU, який ви хочете пропустити. Ідентифікатори повинні відповідати виводам з попереднього етапу. Наприклад, у моєму випадку:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;0000:07:00:0&lt;/code&gt; Advanced Micro Devices, Inc. [AMD/ATI] Navi 23 [Radeon RX 6600/6600 XT/6600M]&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0000:07:00:1&lt;/code&gt; Advanced Micro Devices, Inc. [AMD/ATI] Navi 21/23 HDMI/DP Audio Controller [1002:ab28]&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Вам потрібно це зробити двічі для відеопристрою та аудіопристрою GPU відповідно.&lt;/p&gt;
&lt;p&gt;Потім, якщо у вас є другий монітор, спробуйте підключити його до відеовиходу GPU, який ви пропустили до ВМ, та завантажте ВМ. Якщо все налаштовано правильно, ви повинні побачити відеовихід ВМ на окремому моніторі.&lt;/p&gt;
&lt;h3 id=&#34;встановлення-драйверів-gpu&#34;&gt;Встановлення драйверів GPU&lt;/h3&gt;
&lt;p&gt;Після успішного завантаження вашої Windows ВМ з зовнішнім GPU, час завантажити та встановити останні версії драйверів від виробника вашого GPU.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.nvidia.com/download/index.aspx?lang=en&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Офіційні драйвери для GPU Nvidia&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.amd.com/en/support&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Офіційні драйвери для GPU AMD&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;висновок&#34;&gt;Висновок&lt;/h2&gt;
&lt;p&gt;Налаштована віртуальна машина Windows з пропусканням GPU може обробляти певні графічні програми (наприклад, геймінг або відеомонтаж) з майже нативною продуктивністю, що дозволяє використовувати вашу основну систему Linux та гостьову систему Windows одночасно.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.moroz.cc/post/gpu-pci-passthrough-to-windows-kvm-on-arch-linux/gpu_passthrough_result.jpg&#34;
	width=&#34;4080&#34;
	height=&#34;1292&#34;
	srcset=&#34;https://blog.moroz.cc/post/gpu-pci-passthrough-to-windows-kvm-on-arch-linux/gpu_passthrough_result_hu7478169995235364455.jpg 480w, https://blog.moroz.cc/post/gpu-pci-passthrough-to-windows-kvm-on-arch-linux/gpu_passthrough_result_hu8454564593016997709.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;Результат GPU Passthrough: Windows ВМ ліворуч, Linux host праворуч&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;315&#34;
		data-flex-basis=&#34;757px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;Переваги пропускання GPU в KVM включають:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Покращена продуктивність: Шляхом безпосереднього доступу до фізичного GPU віртуальна машина може досягти майже нативної продуктивності для графічно інтенсивних завдань, таких як геймінг, відеомонтаж та 3D-моделювання.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Зменшення накладних витрат: Оскільки віртуальна машина обходить віртуалізаційний шар гіпервізора для операцій з GPU, накладні витрати менше порівняно з традиційними техніками віртуалізації GPU, такими як емуляція GPU або віртуальні рішення GPU (vGPU).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Підтримка завдань з апаратним прискоренням GPU: Пропускання GPU дозволяє віртуальним машинам використовувати апаратне прискорення для завдань, які покладаються на обробку GPU, що призводить до швидшого виконання та покращеної ефективності.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Сумісність з програмним забезпеченням, яке вимагає GPU: Деякі програми та робочі процеси вимагають прямого доступу до фізичного GPU, що можливо не здійснюється за допомогою віртуальних рішень GPU. Пропускання GPU дозволяє такому програмному забезпеченню працювати безперешкодно в віртуалізованому середовищі.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Геймінг: Гравці можуть скористатися пропусканням GPU, запускаючи ігри в межах віртуальної машини з мінімальним зниженням продуктивності, що дозволяє використовувати апаратно-прискорену графіку без подвійного завантаження або виділення окремої фізичної машини для геймінгу.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>Встановлення системи віртуалізації KVM на Arch Linux</title>
        <link>https://blog.moroz.cc/uk/post/%D0%B2%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%BB%D0%B5%D0%BD%D0%BD%D1%8F-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B8-%D0%B2%D1%96%D1%80%D1%82%D1%83%D0%B0%D0%BB%D1%96%D0%B7%D0%B0%D1%86%D1%96%D1%97-kvm-%D0%BD%D0%B0-arch-linux/</link>
        <pubDate>Fri, 15 Mar 2024 00:00:00 +0000</pubDate>
        
        <guid>https://blog.moroz.cc/uk/post/%D0%B2%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%BB%D0%B5%D0%BD%D0%BD%D1%8F-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B8-%D0%B2%D1%96%D1%80%D1%82%D1%83%D0%B0%D0%BB%D1%96%D0%B7%D0%B0%D1%86%D1%96%D1%97-kvm-%D0%BD%D0%B0-arch-linux/</guid>
        <description>&lt;img src="https://blog.moroz.cc/post/how-to-install-kvm-on-arch-linux/header.png" alt="Featured image of post Встановлення системи віртуалізації KVM на Arch Linux" /&gt;&lt;h2 id=&#34;вступ&#34;&gt;Вступ&lt;/h2&gt;
&lt;p&gt;KVM, що означає Kernel-based Virtual Machine (віртуальна машина на базі ядра), є рішенням для віртуалізації в операційних системах Linux. Воно дозволяє запускати кілька віртуальних машин (ВМ) на одній фізичній машині за допомогою вбудованих у сучасні процесори функцій віртуалізації апаратного забезпечення.&lt;/p&gt;
&lt;p&gt;Ось розбір того, що пропонує KVM:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Гіпервізор&lt;/strong&gt;: KVM діє як гіпервізор, що є частиною програмного забезпечення, яке створює та запускає віртуальні машини. Воно використовує розширення віртуалізації, які присутні в сучасних процесорах (такі як Intel VT-x або AMD-V), для забезпечення апаратно-допомаганої віртуалізації.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Інтеграція з ядром&lt;/strong&gt;: KVM інтегрований у ядро Linux, що означає, що воно використовує функціональність ядра та користується постійними поліпшеннями ядра. Ця інтеграція забезпечує кращу продуктивність та стабільність для віртуалізованих середовищ.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Повна віртуалізація&lt;/strong&gt;: KVM підтримує повну віртуалізацію, що дозволяє гостьовим операційним системам працювати без змін. Це означає, що ви можете запускати різноманітні операційні системи, включаючи Linux, Windows та інші, як віртуальні машини на хості з підтримкою KVM.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Продуктивність&lt;/strong&gt;: KVM відомий своєю високою продуктивністю, завдяки підтримці апаратно-допомаганої віртуалізації та тісної інтеграції з ядром Linux. Це дозволяє ефективне використання ресурсів та мінімальний накладення при запуску віртуалізованих завдань.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Інструменти управління&lt;/strong&gt;: KVM можна керувати за допомогою різних інструментів, включаючи утиліти командного рядка, такі як virsh, та графічні інтерфейси, такі як Virt-Manager. Ці інструменти надають адміністраторам можливість створювати, налаштовувати та управляти віртуальними машинами на хостах з KVM.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Загалом, KVM є потужним та універсальним рішенням для віртуалізації в системах на базі Linux, пропонуючи продуктивність, гнучкість та зручність управління для віртуалізованих середовищ.&lt;/p&gt;
&lt;h2 id=&#34;встановлення&#34;&gt;Встановлення&lt;/h2&gt;
&lt;h3 id=&#34;перевірка-підтримки-віртуалізації&#34;&gt;Перевірка підтримки віртуалізації&lt;/h3&gt;
&lt;p&gt;Перш ніж встановлювати KVM, переконайтеся, що ваш процесор підтримує віртуалізацію та що вона увімкнена у налаштуваннях BIOS. Більшість сучасних процесорів підтримують віртуалізацію, але краще перевірити ще раз.&lt;/p&gt;
&lt;p&gt;Для отримання докладної інформації про перевірку вашого обладнання, будь ласка, зверніться до &lt;a class=&#34;link&#34; href=&#34;https://wiki.archlinux.org/title/KVM#Checking_support_for_KVM&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Arch Wiki - Перевірка підтримки KVM&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&#34;встановлення-пакетів&#34;&gt;Встановлення пакетів&lt;/h3&gt;
&lt;p&gt;Відкрийте термінал та встановіть необхідні пакети. Це включає утиліту образів диска QEMU &lt;code&gt;qemu&lt;/code&gt;, модуль ядра KVM &lt;code&gt;kvm&lt;/code&gt; та API та інструмент управління віртуалізацією libvirt &lt;code&gt;libvirt&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo pacman -S virt-manager virt-viewer qemu dnsmasq bridge-utils&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;налаштування-служби-libvirt&#34;&gt;Налаштування Служби libvirt&lt;/h3&gt;
&lt;p&gt;Libvirt - це набір інструментів для взаємодії з можливостями віртуалізації ядра Linux. Увімкніть службу libvirt для управління віртуальними машинами.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo systemctl &lt;span class=&#34;nb&#34;&gt;enable&lt;/span&gt; --now libvirtd.service&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Увімкніть автозапуск для типової віртуальної мережі NAT для ваших віртуальних машин:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo virsh net-start default
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo virsh net-autostart default&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Потім відредагуйте конфігурацію libvirt у файлі &lt;code&gt;/etc/libvirt/libvirtd.conf&lt;/code&gt; та встановіть параметри:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;unix_sock_group&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;libvirt&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;unix_sock_rw_perms&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;0770&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;Додайте свого поточного користувача до групи &lt;code&gt;libvirt&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo usermod -a -G libvirt &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;whoami&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;newgrp libvirt&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Наостанок, перезапустіть демона libvirt, щоб застосувати зміни:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo systemctl restart libvirtd.service&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Після цього ви повинні мати змогу запустити &lt;code&gt;virt-manager&lt;/code&gt; та використовувати віртуалізацію KVM, але якщо ви побачите деякі помилки, спробуйте перезавантажити вашу машину; якщо це не допоможе, перегляньте журнали та конфігурацію вашого демона libvirt.&lt;/p&gt;
&lt;h3 id=&#34;увімкніть-вкладену-віртуалізацію-необовязково&#34;&gt;Увімкніть вкладену віртуалізацію (необов&amp;rsquo;язково)&lt;/h3&gt;
&lt;p&gt;Вкладена віртуалізація дозволяє запускати існуючі віртуальні машини на сторонніх гіпервізорах та на інших хмарних сервісах без будь-яких змін у початкових віртуальних машинах або їхніх мережах.&lt;/p&gt;
&lt;p&gt;Щоб увімкнути її (тимчасово), скористайтеся наступними командами терміналу:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo modprobe -r kvm_intel  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo modprobe kvm_intel &lt;span class=&#34;nv&#34;&gt;nested&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Потім, щоб перевірити, що вона увімкнена, перевірте результат команди:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;cat /sys/module/kvm_intel/parameters/nested&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;вона повинна надрукувати &lt;code&gt;Y&lt;/code&gt;, якщо вкладена віртуалізація увімкнена.&lt;/p&gt;
&lt;p&gt;Щоб зробити це зміну постійною при завантаженні вашої машини, скористайтеся командою:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;echo&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;options kvm-intel nested=1&amp;#34;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; sudo tee /etc/modprobe.d/kvm-intel.conf&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&#34;посилання&#34;&gt;Посилання&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://wiki.archlinux.org/title/KVM&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Arch Wiki - KVM&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://en.wikipedia.org/wiki/Kernel-based_Virtual_Machine&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Wikipedia - KVM&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://git.kernel.org/pub/scm/virt/kvm/kvm.git&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Вихідний код Kernel Virtual Machine&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
    </channel>
</rss>
